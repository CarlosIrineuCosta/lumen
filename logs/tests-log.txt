============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-7.4.3, pluggy-1.6.0 -- /home/cdc/Storage/NVMe/projects/lumen/backend/venv/bin/python
cachedir: .pytest_cache
rootdir: /home/cdc/Storage/NVMe/projects/lumen
plugins: base-url-2.1.0, Faker-37.6.0, playwright-0.7.0, cov-4.1.0, anyio-3.7.1, mock-3.12.0, asyncio-0.21.1
asyncio: mode=Mode.STRICT
collecting ... collected 599 items

scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_unauthenticated FAILED [  0%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_authenticated FAILED [  0%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_unauthenticated FAILED [  0%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_authenticated FAILED [  0%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_logout_endpoint FAILED [  0%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_test_endpoint FAILED [  1%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint FAILED [  1%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint_unauthenticated FAILED [  1%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_register_user_new PASSED [  1%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_check_registration_existing_user FAILED [  1%]
scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_check_registration_new_user FAILED [  1%]
scripts/tests/test_auth_endpoints.py::TestAuthModels::test_user_profile_model_validation PASSED [  2%]
scripts/tests/test_auth_endpoints.py::TestAuthModels::test_auth_status_model_validation PASSED [  2%]
scripts/tests/test_auth_endpoints.py::TestAuthModels::test_registration_request_model_validation PASSED [  2%]
scripts/tests/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_success PASSED [  2%]
scripts/tests/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_invalid_token PASSED [  2%]
scripts/tests/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_firebase_exception PASSED [  2%]
scripts/tests/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_success PASSED [  3%]
scripts/tests/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_no_credentials PASSED [  3%]
scripts/tests/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_invalid_token PASSED [  3%]
scripts/tests/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_firebase_returns_none PASSED [  3%]
scripts/tests/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_full_data PASSED [  3%]
scripts/tests/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_minimal_data PASSED [  3%]
scripts/tests/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_empty_token PASSED [  4%]
scripts/tests/test_auth_middleware.py::TestAuthUser::test_auth_user_email_verification_false PASSED [  4%]
scripts/tests/test_auth_middleware.py::TestAuthUser::test_auth_user_preserves_token_data PASSED [  4%]
scripts/tests/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_middleware_with_fastapi_dependency_injection FAILED [  4%]
scripts/tests/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_http_bearer_security_scheme PASSED [  4%]
scripts/tests/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_auth_user_as_data_class PASSED [  4%]
scripts/tests/test_database_integration.py::TestDatabaseConnection::test_database_session_creation PASSED [  5%]
scripts/tests/test_database_integration.py::TestDatabaseConnection::test_database_transaction_rollback PASSED [  5%]
scripts/tests/test_database_integration.py::TestUserDatabaseOperations::test_create_user_with_relationships PASSED [  5%]
scripts/tests/test_database_integration.py::TestUserDatabaseOperations::test_user_unique_constraints PASSED [  5%]
scripts/tests/test_database_integration.py::TestUserDatabaseOperations::test_user_cascade_delete PASSED [  5%]
scripts/tests/test_database_integration.py::TestPhotoDatabaseOperations::test_create_photo_with_metadata PASSED [  5%]
scripts/tests/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_search_with_indexes PASSED [  6%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos FAILED [  6%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_list_photos_with_pagination FAILED [  6%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_authenticated FAILED [  6%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_unauthenticated FAILED [  6%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos FAILED [  6%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_photo_by_id FAILED [  7%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_photo_not_found FAILED [  7%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_owner FAILED [  7%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_owner FAILED [  7%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_not_owner FAILED [  7%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_like_photo FAILED [  7%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_search_photos FAILED [  8%]
scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_user_photos_by_handle FAILED [  8%]
scripts/tests/test_photo_endpoints.py::TestPhotoValidation::test_photo_upload_validation PASSED [  8%]
scripts/tests/test_photo_endpoints.py::TestPhotoValidation::test_photo_size_validation PASSED [  8%]
scripts/tests/test_photo_endpoints.py::TestPhotoValidation::test_photo_metadata_validation PASSED [  8%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_photo_model_creation FAILED [  8%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_photo_default_values FAILED [  9%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_photo_repr FAILED [  9%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_like_count_property FAILED [  9%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_collaborator_names_property FAILED [  9%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_photographer_name_property_owner_is_photographer FAILED [  9%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_photographer_name_property_collaborator_is_photographer FAILED [  9%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_location_display_property FAILED [ 10%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_get_tags_combined PASSED [ 10%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_get_tags_combined_with_empty_tags PASSED [ 10%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_is_liked_by_method FAILED [ 10%]
scripts/tests/test_photo_model.py::TestPhotoModel::test_add_collaborator_with_string PASSED [ 10%]
scripts/tests/test_photo_model.py::TestPhotoPydanticModels::test_create_photo_request_validation PASSED [ 10%]
scripts/tests/test_photo_model.py::TestPhotoPydanticModels::test_create_photo_request_validation_errors PASSED [ 11%]
scripts/tests/test_photo_model.py::TestPhotoPydanticModels::test_update_photo_request_validation PASSED [ 11%]
scripts/tests/test_photo_model.py::TestPhotoPydanticModels::test_photo_response_model PASSED [ 11%]
scripts/tests/test_photo_model.py::TestPhotoPydanticModels::test_photo_search_query_validation PASSED [ 11%]
scripts/tests/test_photo_model.py::TestPhotoPydanticModels::test_photo_search_query_defaults PASSED [ 11%]
scripts/tests/test_photo_model.py::TestPhotoPydanticModels::test_photo_list_response PASSED [ 11%]
scripts/tests/test_photo_model.py::TestPhotoPydanticModels::test_photo_metadata_model PASSED [ 12%]
scripts/tests/test_photo_model.py::TestPhotoPydanticModels::test_photo_enums PASSED [ 12%]
scripts/tests/test_photo_upload.py::test_photo_upload PASSED             [ 12%]
scripts/tests/test_user_model.py::TestUserModel::test_user_model_creation FAILED [ 12%]
scripts/tests/test_user_model.py::TestUserModel::test_user_default_values FAILED [ 12%]
scripts/tests/test_user_model.py::TestUserModel::test_user_repr PASSED   [ 12%]
scripts/tests/test_user_model.py::TestUserModel::test_user_type_properties FAILED [ 13%]
scripts/tests/test_user_model.py::TestUserModel::test_location_display_with_privacy FAILED [ 13%]
scripts/tests/test_user_model.py::TestUserModel::test_model_validation_requirements FAILED [ 13%]
scripts/tests/test_user_model.py::TestUserModel::test_photographer_validation_requirements FAILED [ 13%]
scripts/tests/test_user_model.py::TestUserPydanticModels::test_create_user_request_validation PASSED [ 13%]
scripts/tests/test_user_model.py::TestUserPydanticModels::test_create_user_request_validation_errors PASSED [ 13%]
scripts/tests/test_user_model.py::TestUserPydanticModels::test_update_user_request_validation PASSED [ 14%]
scripts/tests/test_user_model.py::TestUserPydanticModels::test_user_profile_models FAILED [ 14%]
scripts/tests/test_user_model.py::TestUserPydanticModels::test_user_search_query_validation PASSED [ 14%]
scripts/tests/test_user_model.py::TestUserPydanticModels::test_user_search_query_defaults PASSED [ 14%]
scripts/tests/test_user_model.py::TestUserPydanticModels::test_photography_style_enum PASSED [ 14%]
scripts/tests/test_user_model.py::TestUserPydanticModels::test_user_type_enum PASSED [ 14%]
scripts/tests/test_user_service.py::TestUserService::test_create_photographer_user FAILED [ 15%]
scripts/tests/test_user_service.py::TestUserService::test_create_model_user FAILED [ 15%]
scripts/tests/test_user_service.py::TestUserService::test_get_user_by_firebase_uid FAILED [ 15%]
scripts/tests/test_user_service.py::TestUserService::test_get_user_by_handle FAILED [ 15%]
scripts/tests/test_user_service.py::TestUserService::test_update_user_profile FAILED [ 15%]
scripts/tests/test_user_service.py::TestUserService::test_validate_unique_handle FAILED [ 15%]
scripts/tests/test_user_service.py::TestUserService::test_user_age_verification FAILED [ 16%]
scripts/tests/test_user_service.py::TestUserService::test_user_search_functionality FAILED [ 16%]
scripts/tests/test_user_service.py::TestUserService::test_user_profile_visibility FAILED [ 16%]
scripts/tests/test_user_service.py::TestUserService::test_user_content_permissions FAILED [ 16%]
scripts/tests/test_user_service.py::TestUserModelIntegration::test_user_model_creation_with_relationships FAILED [ 16%]
scripts/tests/test_user_service.py::TestUserModelIntegration::test_user_cascade_operations FAILED [ 16%]
scripts/tests/diagnostics/test_live_system.py::TestLiveSystemHealth::test_backend_server_accessibility PASSED [ 17%]
scripts/tests/diagnostics/test_live_system.py::TestLiveSystemHealth::test_frontend_server_accessibility PASSED [ 17%]
scripts/tests/diagnostics/test_live_system.py::TestLiveSystemHealth::test_api_documentation_accessible PASSED [ 17%]
scripts/tests/diagnostics/test_live_system.py::TestLiveSystemHealth::test_photos_recent_endpoint_live PASSED [ 17%]
scripts/tests/diagnostics/test_live_system.py::TestLiveSystemHealth::test_authenticated_endpoint_behavior FAILED [ 17%]
scripts/tests/diagnostics/test_live_system.py::TestLiveSystemHealth::test_cors_configuration PASSED [ 17%]
scripts/tests/diagnostics/test_live_system.py::TestLiveSystemPerformance::test_api_response_times PASSED [ 18%]
scripts/tests/diagnostics/test_live_system.py::TestLiveSystemPerformance::test_concurrent_requests PASSED [ 18%]
scripts/tests/diagnostics/test_live_system.py::TestFrontendBackendIntegration::test_frontend_loads_correctly PASSED [ 18%]
scripts/tests/diagnostics/test_live_system.py::TestFrontendBackendIntegration::test_javascript_console_simulation PASSED [ 18%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_database_has_photos PASSED [ 18%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_initialization FAILED [ 18%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_signed_url_generation FAILED [ 19%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_recent_photos_endpoint_unauthenticated PASSED [ 19%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_my_photos_endpoint_authenticated PASSED [ 19%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_recent_photos FAILED [ 19%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_user_photo_relationship PASSED [ 19%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestAuthenticationFlow::test_firebase_token_validation FAILED [ 19%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestAuthenticationFlow::test_auth_middleware_error_handling FAILED [ 20%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestExternalServiceIntegration::test_gcs_bucket_accessibility FAILED [ 20%]
scripts/tests/diagnostics/test_photo_pipeline.py::TestExternalServiceIntegration::test_firebase_admin_connectivity PASSED [ 20%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_unauthenticated ERROR [ 20%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_authenticated ERROR [ 20%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_unauthenticated ERROR [ 20%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_authenticated ERROR [ 21%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_logout_endpoint ERROR [ 21%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_test_endpoint ERROR [ 21%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint ERROR [ 21%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint_unauthenticated ERROR [ 21%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthModels::test_user_profile_model_validation PASSED [ 21%]
scripts/tests/edis-env/test_auth_endpoints.py::TestAuthModels::test_auth_status_model_validation PASSED [ 22%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_success PASSED [ 22%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_invalid_token PASSED [ 22%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_firebase_exception PASSED [ 22%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_success PASSED [ 22%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_no_credentials PASSED [ 22%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_invalid_token PASSED [ 23%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_firebase_returns_none PASSED [ 23%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_full_data PASSED [ 23%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_minimal_data PASSED [ 23%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_empty_token PASSED [ 23%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthUser::test_auth_user_email_verification_false PASSED [ 23%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthUser::test_auth_user_preserves_token_data PASSED [ 24%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_middleware_with_fastapi_dependency_injection FAILED [ 24%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_http_bearer_security_scheme PASSED [ 24%]
scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_auth_user_as_data_class PASSED [ 24%]
scripts/tests/edis-env/test_database_integration.py::TestDatabaseConnection::test_database_session_creation ERROR [ 24%]
scripts/tests/edis-env/test_database_integration.py::TestDatabaseConnection::test_database_transaction_rollback ERROR [ 24%]
scripts/tests/edis-env/test_database_integration.py::TestUserDatabaseOperations::test_create_user_with_relationships ERROR [ 25%]
scripts/tests/edis-env/test_database_integration.py::TestUserDatabaseOperations::test_user_unique_constraints ERROR [ 25%]
scripts/tests/edis-env/test_database_integration.py::TestUserDatabaseOperations::test_user_cascade_delete ERROR [ 25%]
scripts/tests/edis-env/test_database_integration.py::TestPhotoDatabaseOperations::test_create_photo_with_metadata ERROR [ 25%]
scripts/tests/edis-env/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_collaborator_relationships ERROR [ 25%]
scripts/tests/edis-env/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_interaction_tracking ERROR [ 25%]
scripts/tests/edis-env/test_database_integration.py::TestDatabasePerformance::test_user_photo_query_efficiency ERROR [ 26%]
scripts/tests/edis-env/test_database_integration.py::TestDatabasePerformance::test_photo_search_with_indexes ERROR [ 26%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_with_artistic_statement PASSED [ 26%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_photographer_specific PASSED [ 26%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_model_specific PASSED [ 26%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_studio_specific PASSED [ 26%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_availability_data_validation PASSED [ 27%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_availability_data_travel_range_validation PASSED [ 27%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_contact_preferences_validation PASSED [ 27%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_profile_image_data_validation PASSED [ 27%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_profile_image_data_defaults PASSED [ 27%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_enhanced_user_profile_public PASSED [ 27%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_enhanced_user_profile_full PASSED [ 28%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_artistic_statement_max_length_validation PASSED [ 28%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_tagline_max_length_validation PASSED [ 28%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_new_user_types_enum PASSED [ 28%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_expanded_photography_styles_enum PASSED [ 28%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_experience_level_enum PASSED [ 28%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_location_preference_enum PASSED [ 29%]
scripts/tests/edis-env/test_enhanced_user_model.py::TestEnhancedUserModels::test_profile_image_source_enum PASSED [ 29%]
scripts/tests/edis-env/test_id_validation_integration.py::TestIDValidationIntegration::test_valid_firebase_uid_formats FAILED [ 29%]
scripts/tests/edis-env/test_id_validation_integration.py::TestIDValidationIntegration::test_invalid_firebase_uid_formats PASSED [ 29%]
scripts/tests/edis-env/test_id_validation_integration.py::TestIDValidationIntegration::test_valid_uuid_formats PASSED [ 29%]
scripts/tests/edis-env/test_id_validation_integration.py::TestIDValidationIntegration::test_invalid_uuid_formats PASSED [ 29%]
scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_valid_ids ERROR [ 30%]
scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_firebase_uid ERROR [ 30%]
scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_photo_id ERROR [ 30%]
scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_valid_uid ERROR [ 30%]
scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_invalid_uid ERROR [ 30%]
scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_user_id_integration ERROR [ 30%]
scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_photo_id_integration ERROR [ 31%]
scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_generate_storage_paths_integration ERROR [ 31%]
scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_parse_storage_path_integration ERROR [ 31%]
scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_prepare_ids_for_operation_integration ERROR [ 31%]
scripts/tests/edis-env/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_complete_photo_upload_flow ERROR [ 31%]
scripts/tests/edis-env/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_photo_retrieval_with_id_validation ERROR [ 31%]
scripts/tests/edis-env/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_invalid_id_formats_rejected_in_flow ERROR [ 32%]
scripts/tests/edis-env/test_live_system.py::TestLiveSystemHealth::test_backend_server_accessibility PASSED [ 32%]
scripts/tests/edis-env/test_live_system.py::TestLiveSystemHealth::test_frontend_server_accessibility PASSED [ 32%]
scripts/tests/edis-env/test_live_system.py::TestLiveSystemHealth::test_api_documentation_accessible PASSED [ 32%]
scripts/tests/edis-env/test_live_system.py::TestLiveSystemHealth::test_photos_recent_endpoint_live PASSED [ 32%]
scripts/tests/edis-env/test_live_system.py::TestLiveSystemHealth::test_authenticated_endpoint_behavior FAILED [ 32%]
scripts/tests/edis-env/test_live_system.py::TestLiveSystemHealth::test_cors_configuration PASSED [ 33%]
scripts/tests/edis-env/test_live_system.py::TestLiveSystemPerformance::test_api_response_times PASSED [ 33%]
scripts/tests/edis-env/test_live_system.py::TestLiveSystemPerformance::test_concurrent_requests PASSED [ 33%]
scripts/tests/edis-env/test_live_system.py::TestFrontendBackendIntegration::test_frontend_loads_correctly PASSED [ 33%]
scripts/tests/edis-env/test_live_system.py::TestFrontendBackendIntegration::test_javascript_console_simulation PASSED [ 33%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_empty ERROR [ 33%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_with_pagination ERROR [ 34%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_invalid_pagination ERROR [ 34%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_list_photos_public_endpoint ERROR [ 34%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_nonexistent_photo ERROR [ 34%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_authenticated ERROR [ 34%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_unauthenticated ERROR [ 34%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_user_photos_endpoint ERROR [ 35%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_specific_user_photos ERROR [ 35%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_success ERROR [ 35%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_unauthenticated ERROR [ 35%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_invalid_file_type ERROR [ 35%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_authenticated ERROR [ 35%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_unauthenticated ERROR [ 36%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_authenticated ERROR [ 36%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_unauthenticated ERROR [ 36%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_like_photo_not_implemented ERROR [ 36%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_search_photos_not_implemented ERROR [ 36%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoModels::test_photo_upload_form_validation PASSED [ 36%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoModels::test_photo_tags_parsing PASSED [ 37%]
scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoModels::test_empty_tags_handling PASSED [ 37%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photo_model_creation ERROR [ 37%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photo_default_values ERROR [ 37%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photo_repr ERROR [ 37%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_like_count_property FAILED [ 37%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_collaborator_names_property FAILED [ 38%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photographer_name_property_owner_is_photographer FAILED [ 38%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photographer_name_property_collaborator_is_photographer FAILED [ 38%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_location_display_property FAILED [ 38%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_get_tags_combined PASSED [ 38%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_get_tags_combined_with_empty_tags PASSED [ 38%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_is_liked_by_method FAILED [ 39%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_add_collaborator_with_string PASSED [ 39%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoPydanticModels::test_create_photo_request_validation PASSED [ 39%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoPydanticModels::test_create_photo_request_validation_errors PASSED [ 39%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoPydanticModels::test_update_photo_request_validation PASSED [ 39%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoPydanticModels::test_photo_response_model PASSED [ 39%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoPydanticModels::test_photo_search_query_validation PASSED [ 40%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoPydanticModels::test_photo_search_query_defaults PASSED [ 40%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoPydanticModels::test_photo_list_response PASSED [ 40%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoPydanticModels::test_photo_metadata_model PASSED [ 40%]
scripts/tests/edis-env/test_photo_model.py::TestPhotoPydanticModels::test_photo_enums PASSED [ 40%]
scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_database_has_photos PASSED [ 40%]
scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_initialization FAILED [ 41%]
scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_signed_url_generation FAILED [ 41%]
scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_recent_photos_endpoint_unauthenticated PASSED [ 41%]
scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_my_photos_endpoint_authenticated PASSED [ 41%]
scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_recent_photos FAILED [ 41%]
scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_user_photo_relationship PASSED [ 41%]
scripts/tests/edis-env/test_photo_pipeline.py::TestAuthenticationFlow::test_firebase_token_validation FAILED [ 42%]
scripts/tests/edis-env/test_photo_pipeline.py::TestAuthenticationFlow::test_auth_middleware_error_handling FAILED [ 42%]
scripts/tests/edis-env/test_photo_pipeline.py::TestExternalServiceIntegration::test_gcs_bucket_accessibility FAILED [ 42%]
scripts/tests/edis-env/test_photo_pipeline.py::TestExternalServiceIntegration::test_firebase_admin_connectivity PASSED [ 42%]
scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_get_deletion_summary ERROR [ 42%]
scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_delete_user_account_success ERROR [ 42%]
scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_delete_nonexistent_user FAILED [ 43%]
scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_deletion_with_storage_errors ERROR [ 43%]
scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_deletion_rollback_on_db_error ERROR [ 43%]
scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_gmail_profile_image_not_deleted FAILED [ 43%]
scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_orphaned_photos_check PASSED [ 43%]
scripts/tests/edis-env/test_user_deletion.py::test_delete_user_endpoint_requires_confirmation ERROR [ 43%]
scripts/tests/edis-env/test_user_model.py::TestUserModel::test_user_model_creation ERROR [ 44%]
scripts/tests/edis-env/test_user_model.py::TestUserModel::test_user_default_values ERROR [ 44%]
scripts/tests/edis-env/test_user_model.py::TestUserModel::test_user_repr ERROR [ 44%]
scripts/tests/edis-env/test_user_model.py::TestUserModel::test_user_type_properties FAILED [ 44%]
scripts/tests/edis-env/test_user_model.py::TestUserModel::test_location_display_with_privacy FAILED [ 44%]
scripts/tests/edis-env/test_user_model.py::TestUserModel::test_model_validation_requirements FAILED [ 44%]
scripts/tests/edis-env/test_user_model.py::TestUserModel::test_photographer_validation_requirements FAILED [ 45%]
scripts/tests/edis-env/test_user_model.py::TestUserPydanticModels::test_create_user_request_validation PASSED [ 45%]
scripts/tests/edis-env/test_user_model.py::TestUserPydanticModels::test_create_user_request_validation_errors PASSED [ 45%]
scripts/tests/edis-env/test_user_model.py::TestUserPydanticModels::test_update_user_request_validation PASSED [ 45%]
scripts/tests/edis-env/test_user_model.py::TestUserPydanticModels::test_user_profile_models FAILED [ 45%]
scripts/tests/edis-env/test_user_model.py::TestUserPydanticModels::test_user_search_query_validation PASSED [ 45%]
scripts/tests/edis-env/test_user_model.py::TestUserPydanticModels::test_user_search_query_defaults PASSED [ 46%]
scripts/tests/edis-env/test_user_model.py::TestUserPydanticModels::test_photography_style_enum PASSED [ 46%]
scripts/tests/edis-env/test_user_model.py::TestUserPydanticModels::test_user_type_enum PASSED [ 46%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_with_artistic_statement FAILED [ 46%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_photographer_specific_fields FAILED [ 46%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_model_specific_fields FAILED [ 46%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_availability_data FAILED [ 47%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_success FAILED [ 47%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_failure FAILED [ 47%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_profile_image_url FAILED [ 47%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_remove_profile_image FAILED [ 47%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_user_exists PASSED [ 47%]
scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_get_user_stats FAILED [ 48%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestLiveSystemHealth::test_backend_server_accessibility PASSED [ 48%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestLiveSystemHealth::test_frontend_server_accessibility PASSED [ 48%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestLiveSystemHealth::test_api_documentation_accessible PASSED [ 48%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestLiveSystemHealth::test_photos_recent_endpoint_live PASSED [ 48%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestLiveSystemHealth::test_authenticated_endpoint_behavior FAILED [ 48%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestLiveSystemHealth::test_cors_configuration PASSED [ 49%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestLiveSystemPerformance::test_api_response_times PASSED [ 49%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestLiveSystemPerformance::test_concurrent_requests PASSED [ 49%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestFrontendBackendIntegration::test_frontend_loads_correctly PASSED [ 49%]
scripts/tests/edis-env/diagnostics/test_live_system.py::TestFrontendBackendIntegration::test_javascript_console_simulation PASSED [ 49%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_database_has_photos PASSED [ 49%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_initialization FAILED [ 50%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_signed_url_generation FAILED [ 50%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_recent_photos_endpoint_unauthenticated PASSED [ 50%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_my_photos_endpoint_authenticated PASSED [ 50%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_recent_photos FAILED [ 50%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_user_photo_relationship PASSED [ 50%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestAuthenticationFlow::test_firebase_token_validation FAILED [ 51%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestAuthenticationFlow::test_auth_middleware_error_handling FAILED [ 51%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestExternalServiceIntegration::test_gcs_bucket_accessibility FAILED [ 51%]
scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestExternalServiceIntegration::test_firebase_admin_connectivity PASSED [ 51%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_unauthenticated ERROR [ 51%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_authenticated ERROR [ 51%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_unauthenticated ERROR [ 52%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_authenticated ERROR [ 52%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_logout_endpoint ERROR [ 52%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_test_endpoint ERROR [ 52%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint ERROR [ 52%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint_unauthenticated ERROR [ 52%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthModels::test_user_profile_model_validation PASSED [ 53%]
scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthModels::test_auth_status_model_validation PASSED [ 53%]
scripts/tests/edis-env/integration/test_database_integration.py::TestDatabaseConnection::test_database_session_creation ERROR [ 53%]
scripts/tests/edis-env/integration/test_database_integration.py::TestDatabaseConnection::test_database_transaction_rollback ERROR [ 53%]
scripts/tests/edis-env/integration/test_database_integration.py::TestUserDatabaseOperations::test_create_user_with_relationships ERROR [ 53%]
scripts/tests/edis-env/integration/test_database_integration.py::TestUserDatabaseOperations::test_user_unique_constraints ERROR [ 53%]
scripts/tests/edis-env/integration/test_database_integration.py::TestUserDatabaseOperations::test_user_cascade_delete ERROR [ 54%]
scripts/tests/edis-env/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_create_photo_with_metadata ERROR [ 54%]
scripts/tests/edis-env/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_collaborator_relationships ERROR [ 54%]
scripts/tests/edis-env/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_interaction_tracking ERROR [ 54%]
scripts/tests/edis-env/integration/test_database_integration.py::TestDatabasePerformance::test_user_photo_query_efficiency ERROR [ 54%]
scripts/tests/edis-env/integration/test_database_integration.py::TestDatabasePerformance::test_photo_search_with_indexes ERROR [ 54%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_valid_firebase_uid_formats FAILED [ 55%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_invalid_firebase_uid_formats PASSED [ 55%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_valid_uuid_formats PASSED [ 55%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_invalid_uuid_formats PASSED [ 55%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_valid_ids ERROR [ 55%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_firebase_uid ERROR [ 55%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_photo_id ERROR [ 56%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_valid_uid ERROR [ 56%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_invalid_uid ERROR [ 56%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_user_id_integration ERROR [ 56%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_photo_id_integration ERROR [ 56%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_generate_storage_paths_integration ERROR [ 56%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_parse_storage_path_integration ERROR [ 57%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_prepare_ids_for_operation_integration ERROR [ 57%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_complete_photo_upload_flow ERROR [ 57%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_photo_retrieval_with_id_validation ERROR [ 57%]
scripts/tests/edis-env/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_invalid_id_formats_rejected_in_flow ERROR [ 57%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_empty ERROR [ 57%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_with_pagination ERROR [ 58%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_invalid_pagination ERROR [ 58%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_list_photos_public_endpoint ERROR [ 58%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_nonexistent_photo ERROR [ 58%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_authenticated ERROR [ 58%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_unauthenticated ERROR [ 58%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_user_photos_endpoint ERROR [ 59%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_specific_user_photos ERROR [ 59%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_success ERROR [ 59%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_unauthenticated ERROR [ 59%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_invalid_file_type ERROR [ 59%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_authenticated ERROR [ 59%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_unauthenticated ERROR [ 60%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_authenticated ERROR [ 60%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_unauthenticated ERROR [ 60%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_like_photo_not_implemented ERROR [ 60%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_search_photos_not_implemented ERROR [ 60%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoModels::test_photo_upload_form_validation PASSED [ 60%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoModels::test_photo_tags_parsing PASSED [ 61%]
scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoModels::test_empty_tags_handling PASSED [ 61%]
scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_get_deletion_summary ERROR [ 61%]
scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_delete_user_account_success ERROR [ 61%]
scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_delete_nonexistent_user FAILED [ 61%]
scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_deletion_with_storage_errors ERROR [ 61%]
scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_deletion_rollback_on_db_error ERROR [ 62%]
scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_gmail_profile_image_not_deleted FAILED [ 62%]
scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_orphaned_photos_check PASSED [ 62%]
scripts/tests/edis-env/integration/test_user_deletion.py::test_delete_user_endpoint_requires_confirmation ERROR [ 62%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_success PASSED [ 62%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_invalid_token PASSED [ 62%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_firebase_exception PASSED [ 63%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_success PASSED [ 63%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_no_credentials PASSED [ 63%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_invalid_token PASSED [ 63%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_firebase_returns_none PASSED [ 63%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_full_data PASSED [ 63%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_minimal_data PASSED [ 64%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_empty_token PASSED [ 64%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_email_verification_false PASSED [ 64%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_preserves_token_data PASSED [ 64%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_middleware_with_fastapi_dependency_injection FAILED [ 64%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_http_bearer_security_scheme PASSED [ 64%]
scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_auth_user_as_data_class PASSED [ 65%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_with_artistic_statement PASSED [ 65%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_photographer_specific PASSED [ 65%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_model_specific PASSED [ 65%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_studio_specific PASSED [ 65%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_availability_data_validation PASSED [ 65%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_availability_data_travel_range_validation PASSED [ 66%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_contact_preferences_validation PASSED [ 66%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_profile_image_data_validation PASSED [ 66%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_profile_image_data_defaults PASSED [ 66%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_enhanced_user_profile_public PASSED [ 66%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_enhanced_user_profile_full PASSED [ 66%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_artistic_statement_max_length_validation PASSED [ 67%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_tagline_max_length_validation PASSED [ 67%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_new_user_types_enum PASSED [ 67%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_expanded_photography_styles_enum PASSED [ 67%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_experience_level_enum PASSED [ 67%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_location_preference_enum PASSED [ 67%]
scripts/tests/edis-env/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_profile_image_source_enum PASSED [ 68%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photo_model_creation ERROR [ 68%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photo_default_values ERROR [ 68%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photo_repr ERROR [ 68%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_like_count_property FAILED [ 68%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_collaborator_names_property FAILED [ 68%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photographer_name_property_owner_is_photographer FAILED [ 69%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photographer_name_property_collaborator_is_photographer FAILED [ 69%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_location_display_property FAILED [ 69%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_get_tags_combined PASSED [ 69%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_get_tags_combined_with_empty_tags PASSED [ 69%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_is_liked_by_method FAILED [ 69%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_add_collaborator_with_string PASSED [ 70%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoPydanticModels::test_create_photo_request_validation PASSED [ 70%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoPydanticModels::test_create_photo_request_validation_errors PASSED [ 70%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoPydanticModels::test_update_photo_request_validation PASSED [ 70%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_response_model PASSED [ 70%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_search_query_validation PASSED [ 70%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_search_query_defaults PASSED [ 71%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_list_response PASSED [ 71%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_metadata_model PASSED [ 71%]
scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_enums PASSED [ 71%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_user_model_creation ERROR [ 71%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_user_default_values ERROR [ 71%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_user_repr ERROR [ 72%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_user_type_properties FAILED [ 72%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_location_display_with_privacy FAILED [ 72%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_model_validation_requirements FAILED [ 72%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_photographer_validation_requirements FAILED [ 72%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserPydanticModels::test_create_user_request_validation PASSED [ 72%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserPydanticModels::test_create_user_request_validation_errors PASSED [ 73%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserPydanticModels::test_update_user_request_validation PASSED [ 73%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserPydanticModels::test_user_profile_models FAILED [ 73%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserPydanticModels::test_user_search_query_validation PASSED [ 73%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserPydanticModels::test_user_search_query_defaults PASSED [ 73%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserPydanticModels::test_photography_style_enum PASSED [ 73%]
scripts/tests/edis-env/unit/test_user_model.py::TestUserPydanticModels::test_user_type_enum PASSED [ 74%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_with_artistic_statement FAILED [ 74%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_photographer_specific_fields FAILED [ 74%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_model_specific_fields FAILED [ 74%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_availability_data FAILED [ 74%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_success FAILED [ 74%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_failure FAILED [ 75%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_profile_image_url FAILED [ 75%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_remove_profile_image FAILED [ 75%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_user_exists PASSED [ 75%]
scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_get_user_stats FAILED [ 75%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_unauthenticated FAILED [ 75%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_authenticated FAILED [ 76%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_unauthenticated FAILED [ 76%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_authenticated FAILED [ 76%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_logout_endpoint PASSED [ 76%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_test_endpoint PASSED [ 76%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint FAILED [ 76%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint_unauthenticated FAILED [ 77%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthModels::test_user_profile_model_validation PASSED [ 77%]
scripts/tests/integration/test_auth_endpoints.py::TestAuthModels::test_auth_status_model_validation PASSED [ 77%]
scripts/tests/integration/test_database_integration.py::TestDatabaseConnection::test_database_session_creation FAILED [ 77%]
scripts/tests/integration/test_database_integration.py::TestDatabaseConnection::test_database_transaction_rollback FAILED [ 77%]
scripts/tests/integration/test_database_integration.py::TestUserDatabaseOperations::test_create_user_with_relationships FAILED [ 77%]
scripts/tests/integration/test_database_integration.py::TestUserDatabaseOperations::test_user_unique_constraints FAILED [ 78%]
scripts/tests/integration/test_database_integration.py::TestUserDatabaseOperations::test_user_cascade_delete FAILED [ 78%]
scripts/tests/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_create_photo_with_metadata FAILED [ 78%]
scripts/tests/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_collaborator_relationships FAILED [ 78%]
scripts/tests/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_interaction_tracking FAILED [ 78%]
scripts/tests/integration/test_database_integration.py::TestDatabasePerformance::test_user_photo_query_efficiency FAILED [ 78%]
scripts/tests/integration/test_database_integration.py::TestDatabasePerformance::test_photo_search_with_indexes FAILED [ 79%]
scripts/tests/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_valid_firebase_uid_formats FAILED [ 79%]
scripts/tests/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_invalid_firebase_uid_formats PASSED [ 79%]
scripts/tests/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_valid_uuid_formats PASSED [ 79%]
scripts/tests/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_invalid_uuid_formats PASSED [ 79%]
scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_valid_ids ERROR [ 79%]
scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_firebase_uid ERROR [ 80%]
scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_photo_id FAILED [ 80%]
scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_valid_uid FAILED [ 80%]
scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_invalid_uid FAILED [ 80%]
scripts/tests/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_user_id_integration PASSED [ 80%]
scripts/tests/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_photo_id_integration PASSED [ 80%]
scripts/tests/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_generate_storage_paths_integration PASSED [ 81%]
scripts/tests/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_parse_storage_path_integration PASSED [ 81%]
scripts/tests/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_prepare_ids_for_operation_integration PASSED [ 81%]
scripts/tests/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_complete_photo_upload_flow FAILED [ 81%]
scripts/tests/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_photo_retrieval_with_id_validation FAILED [ 81%]
scripts/tests/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_invalid_id_formats_rejected_in_flow FAILED [ 81%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_empty FAILED [ 82%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_with_pagination FAILED [ 82%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_invalid_pagination PASSED [ 82%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_list_photos_public_endpoint FAILED [ 82%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_nonexistent_photo FAILED [ 82%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_authenticated FAILED [ 82%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_unauthenticated FAILED [ 83%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_user_photos_endpoint FAILED [ 83%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_specific_user_photos FAILED [ 83%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_success FAILED [ 83%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_unauthenticated FAILED [ 83%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_invalid_file_type FAILED [ 83%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_authenticated FAILED [ 84%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_unauthenticated FAILED [ 84%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_authenticated FAILED [ 84%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_unauthenticated FAILED [ 84%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_like_photo_not_implemented FAILED [ 84%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_search_photos_not_implemented FAILED [ 84%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoModels::test_photo_upload_form_validation PASSED [ 85%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoModels::test_photo_tags_parsing PASSED [ 85%]
scripts/tests/integration/test_photo_endpoints.py::TestPhotoModels::test_empty_tags_handling PASSED [ 85%]
scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_get_deletion_summary ERROR [ 85%]
scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_delete_user_account_success ERROR [ 85%]
scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_delete_nonexistent_user FAILED [ 85%]
scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_deletion_with_storage_errors ERROR [ 86%]
scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_deletion_rollback_on_db_error ERROR [ 86%]
scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_gmail_profile_image_not_deleted FAILED [ 86%]
scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_orphaned_photos_check FAILED [ 86%]
scripts/tests/integration/test_user_deletion.py::test_delete_user_endpoint_requires_confirmation FAILED [ 86%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_success FAILED [ 86%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_invalid_token FAILED [ 87%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_firebase_exception FAILED [ 87%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_success FAILED [ 87%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_no_credentials FAILED [ 87%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_invalid_token FAILED [ 87%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_firebase_returns_none FAILED [ 87%]
scripts/tests/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_full_data PASSED [ 88%]
scripts/tests/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_minimal_data PASSED [ 88%]
scripts/tests/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_creation_empty_token PASSED [ 88%]
scripts/tests/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_email_verification_false PASSED [ 88%]
scripts/tests/unit/test_auth_middleware.py::TestAuthUser::test_auth_user_preserves_token_data PASSED [ 88%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_middleware_with_fastapi_dependency_injection FAILED [ 88%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_http_bearer_security_scheme PASSED [ 89%]
scripts/tests/unit/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_auth_user_as_data_class PASSED [ 89%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_with_artistic_statement PASSED [ 89%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_photographer_specific PASSED [ 89%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_model_specific PASSED [ 89%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_update_user_request_studio_specific PASSED [ 89%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_availability_data_validation PASSED [ 90%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_availability_data_travel_range_validation PASSED [ 90%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_contact_preferences_validation PASSED [ 90%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_profile_image_data_validation PASSED [ 90%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_profile_image_data_defaults PASSED [ 90%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_enhanced_user_profile_public PASSED [ 90%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_enhanced_user_profile_full PASSED [ 91%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_artistic_statement_max_length_validation PASSED [ 91%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_tagline_max_length_validation PASSED [ 91%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_new_user_types_enum PASSED [ 91%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_expanded_photography_styles_enum PASSED [ 91%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_experience_level_enum PASSED [ 91%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_location_preference_enum PASSED [ 92%]
scripts/tests/unit/test_enhanced_user_model.py::TestEnhancedUserModels::test_profile_image_source_enum PASSED [ 92%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photo_model_creation FAILED [ 92%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photo_default_values FAILED [ 92%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photo_repr FAILED [ 92%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_like_count_property FAILED [ 92%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_collaborator_names_property FAILED [ 93%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photographer_name_property_owner_is_photographer FAILED [ 93%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photographer_name_property_collaborator_is_photographer FAILED [ 93%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_location_display_property FAILED [ 93%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_get_tags_combined PASSED [ 93%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_get_tags_combined_with_empty_tags PASSED [ 93%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_is_liked_by_method FAILED [ 94%]
scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_add_collaborator_with_string PASSED [ 94%]
scripts/tests/unit/test_photo_model.py::TestPhotoPydanticModels::test_create_photo_request_validation PASSED [ 94%]
scripts/tests/unit/test_photo_model.py::TestPhotoPydanticModels::test_create_photo_request_validation_errors PASSED [ 94%]
scripts/tests/unit/test_photo_model.py::TestPhotoPydanticModels::test_update_photo_request_validation PASSED [ 94%]
scripts/tests/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_response_model PASSED [ 94%]
scripts/tests/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_search_query_validation PASSED [ 95%]
scripts/tests/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_search_query_defaults PASSED [ 95%]
scripts/tests/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_list_response PASSED [ 95%]
scripts/tests/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_metadata_model PASSED [ 95%]
scripts/tests/unit/test_photo_model.py::TestPhotoPydanticModels::test_photo_enums PASSED [ 95%]
scripts/tests/unit/test_user_model.py::TestUserModel::test_user_model_creation FAILED [ 95%]
scripts/tests/unit/test_user_model.py::TestUserModel::test_user_default_values FAILED [ 96%]
scripts/tests/unit/test_user_model.py::TestUserModel::test_user_repr PASSED [ 96%]
scripts/tests/unit/test_user_model.py::TestUserModel::test_user_type_properties FAILED [ 96%]
scripts/tests/unit/test_user_model.py::TestUserModel::test_location_display_with_privacy FAILED [ 96%]
scripts/tests/unit/test_user_model.py::TestUserModel::test_model_validation_requirements FAILED [ 96%]
scripts/tests/unit/test_user_model.py::TestUserModel::test_photographer_validation_requirements FAILED [ 96%]
scripts/tests/unit/test_user_model.py::TestUserPydanticModels::test_create_user_request_validation PASSED [ 97%]
scripts/tests/unit/test_user_model.py::TestUserPydanticModels::test_create_user_request_validation_errors PASSED [ 97%]
scripts/tests/unit/test_user_model.py::TestUserPydanticModels::test_update_user_request_validation PASSED [ 97%]
scripts/tests/unit/test_user_model.py::TestUserPydanticModels::test_user_profile_models FAILED [ 97%]
scripts/tests/unit/test_user_model.py::TestUserPydanticModels::test_user_search_query_validation PASSED [ 97%]
scripts/tests/unit/test_user_model.py::TestUserPydanticModels::test_user_search_query_defaults PASSED [ 97%]
scripts/tests/unit/test_user_model.py::TestUserPydanticModels::test_photography_style_enum PASSED [ 98%]
scripts/tests/unit/test_user_model.py::TestUserPydanticModels::test_user_type_enum PASSED [ 98%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_with_artistic_statement FAILED [ 98%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_photographer_specific_fields FAILED [ 98%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_model_specific_fields FAILED [ 98%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_availability_data FAILED [ 98%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_success FAILED [ 99%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_failure FAILED [ 99%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_profile_image_url FAILED [ 99%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_remove_profile_image FAILED [ 99%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_user_exists FAILED [ 99%]
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_get_user_stats FAILED [100%]

==================================== ERRORS ====================================
_____ ERROR at setup of TestAuthEndpoints.test_auth_status_unauthenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db0f7cf90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestAuthEndpoints.test_auth_status_authenticated ______

self = <sqlalchemy.engine.base.Connection object at 0x718db13fa410>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_____ ERROR at setup of TestAuthEndpoints.test_get_profile_unauthenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db1a17610>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestAuthEndpoints.test_get_profile_authenticated ______

self = <sqlalchemy.engine.base.Connection object at 0x718db1091b90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___________ ERROR at setup of TestAuthEndpoints.test_logout_endpoint ___________

self = <sqlalchemy.engine.base.Connection object at 0x718db1f2cd10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____________ ERROR at setup of TestAuthEndpoints.test_test_endpoint ____________

self = <sqlalchemy.engine.base.Connection object at 0x718db1a7d350>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_______ ERROR at setup of TestAuthEndpoints.test_demo_protected_endpoint _______

self = <sqlalchemy.engine.base.Connection object at 0x718db1274b90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestAuthEndpoints.test_demo_protected_endpoint_unauthenticated _

self = <sqlalchemy.engine.base.Connection object at 0x718db13387d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestDatabaseConnection.test_database_session_creation ____

self = <sqlalchemy.engine.base.Connection object at 0x718db11ba010>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestDatabaseConnection.test_database_transaction_rollback __

self = <sqlalchemy.engine.base.Connection object at 0x718db1a00990>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestUserDatabaseOperations.test_create_user_with_relationships _

self = <sqlalchemy.engine.base.Connection object at 0x718db10a55d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
__ ERROR at setup of TestUserDatabaseOperations.test_user_unique_constraints ___

self = <sqlalchemy.engine.base.Connection object at 0x718db1d64d90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestUserDatabaseOperations.test_user_cascade_delete _____

self = <sqlalchemy.engine.base.Connection object at 0x718db1c3d150>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoDatabaseOperations.test_create_photo_with_metadata _

self = <sqlalchemy.engine.base.Connection object at 0x718db1a5d790>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoDatabaseOperations.test_photo_collaborator_relationships _

self = <sqlalchemy.engine.base.Connection object at 0x718db10c5dd0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoDatabaseOperations.test_photo_interaction_tracking _

self = <sqlalchemy.engine.base.Connection object at 0x718db139e690>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
__ ERROR at setup of TestDatabasePerformance.test_user_photo_query_efficiency __

self = <sqlalchemy.engine.base.Connection object at 0x718db11067d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestDatabasePerformance.test_photo_search_with_indexes ___

self = <sqlalchemy.engine.base.Connection object at 0x718db0f5aa90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_photo_service_with_valid_ids _

self = <sqlalchemy.engine.base.Connection object at 0x718db1391e90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_photo_service_with_invalid_firebase_uid _

self = <sqlalchemy.engine.base.Connection object at 0x718db1d5d490>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_photo_service_with_invalid_photo_id _

self = <sqlalchemy.engine.base.Connection object at 0x718db14880d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_ensure_user_exists_with_valid_uid _

self = <sqlalchemy.engine.base.Connection object at 0x718db14033d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_ensure_user_exists_with_invalid_uid _

self = <sqlalchemy.engine.base.Connection object at 0x718db113d390>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_normalize_user_id_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db1444c10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_normalize_photo_id_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db14b2010>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_generate_storage_paths_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db143a5d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_parse_storage_path_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db14525d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_prepare_ids_for_operation_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db149ae10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestEndToEndPhotoFlow.test_complete_photo_upload_flow ____

self = <sqlalchemy.engine.base.Connection object at 0x718db1477610>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestEndToEndPhotoFlow.test_photo_retrieval_with_id_validation _

self = <sqlalchemy.engine.base.Connection object at 0x718db1aebb90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestEndToEndPhotoFlow.test_invalid_id_formats_rejected_in_flow _

self = <sqlalchemy.engine.base.Connection object at 0x718db1a114d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestPhotoEndpoints.test_get_recent_photos_empty _______

self = <sqlalchemy.engine.base.Connection object at 0x718db18336d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoEndpoints.test_get_recent_photos_with_pagination __

self = <sqlalchemy.engine.base.Connection object at 0x718db14e54d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoEndpoints.test_get_recent_photos_invalid_pagination _

self = <sqlalchemy.engine.base.Connection object at 0x718db20b1ad0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_list_photos_public_endpoint _____

self = <sqlalchemy.engine.base.Connection object at 0x718db20eea90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_______ ERROR at setup of TestPhotoEndpoints.test_get_nonexistent_photo ________

self = <sqlalchemy.engine.base.Connection object at 0x718db20d5290>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_get_my_photos_authenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db2019810>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestPhotoEndpoints.test_get_my_photos_unauthenticated ____

self = <sqlalchemy.engine.base.Connection object at 0x718db20eb3d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestPhotoEndpoints.test_get_user_photos_endpoint ______

self = <sqlalchemy.engine.base.Connection object at 0x718db1185410>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestPhotoEndpoints.test_get_specific_user_photos ______

self = <sqlalchemy.engine.base.Connection object at 0x718db10a5d90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
________ ERROR at setup of TestPhotoEndpoints.test_upload_photo_success ________

self = <sqlalchemy.engine.base.Connection object at 0x718db20854d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_upload_photo_unauthenticated ____

self = <sqlalchemy.engine.base.Connection object at 0x718db20c0bd0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestPhotoEndpoints.test_upload_invalid_file_type ______

self = <sqlalchemy.engine.base.Connection object at 0x718db0f4cb50>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_____ ERROR at setup of TestPhotoEndpoints.test_update_photo_authenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db2044e90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_update_photo_unauthenticated ____

self = <sqlalchemy.engine.base.Connection object at 0x718db1a51010>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_____ ERROR at setup of TestPhotoEndpoints.test_delete_photo_authenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db0f654d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_delete_photo_unauthenticated ____

self = <sqlalchemy.engine.base.Connection object at 0x718db2000d10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_____ ERROR at setup of TestPhotoEndpoints.test_like_photo_not_implemented _____

self = <sqlalchemy.engine.base.Connection object at 0x718db1a91390>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestPhotoEndpoints.test_search_photos_not_implemented ____

self = <sqlalchemy.engine.base.Connection object at 0x718db0f48d50>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
__________ ERROR at setup of TestPhotoModel.test_photo_model_creation __________

self = <sqlalchemy.engine.base.Connection object at 0x718db1e9ca10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
__________ ERROR at setup of TestPhotoModel.test_photo_default_values __________

self = <sqlalchemy.engine.base.Connection object at 0x718db0e15490>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ ERROR at setup of TestPhotoModel.test_photo_repr _______________

self = <sqlalchemy.engine.base.Connection object at 0x718db1ea0e50>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_________ ERROR at setup of TestUserDeletion.test_get_deletion_summary _________

self = <test_user_deletion.TestUserDeletion object at 0x718db2f063d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
_____ ERROR at setup of TestUserDeletion.test_delete_user_account_success ______

self = <test_user_deletion.TestUserDeletion object at 0x718db30ff550>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
_____ ERROR at setup of TestUserDeletion.test_deletion_with_storage_errors _____

self = <test_user_deletion.TestUserDeletion object at 0x718db2f11bd0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
____ ERROR at setup of TestUserDeletion.test_deletion_rollback_on_db_error _____

self = <test_user_deletion.TestUserDeletion object at 0x718db2f11f50>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
______ ERROR at setup of test_delete_user_endpoint_requires_confirmation _______

self = <sqlalchemy.engine.base.Connection object at 0x718db2045f90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___________ ERROR at setup of TestUserModel.test_user_model_creation ___________

self = <sqlalchemy.engine.base.Connection object at 0x718db0ea6ad0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___________ ERROR at setup of TestUserModel.test_user_default_values ___________

self = <sqlalchemy.engine.base.Connection object at 0x718db0e6f550>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
________________ ERROR at setup of TestUserModel.test_user_repr ________________

self = <sqlalchemy.engine.base.Connection object at 0x718db0e5f610>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_____ ERROR at setup of TestAuthEndpoints.test_auth_status_unauthenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db201bd90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestAuthEndpoints.test_auth_status_authenticated ______

self = <sqlalchemy.engine.base.Connection object at 0x718db0582890>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_____ ERROR at setup of TestAuthEndpoints.test_get_profile_unauthenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db056f390>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestAuthEndpoints.test_get_profile_authenticated ______

self = <sqlalchemy.engine.base.Connection object at 0x718db05bd410>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___________ ERROR at setup of TestAuthEndpoints.test_logout_endpoint ___________

self = <sqlalchemy.engine.base.Connection object at 0x718db058d9d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____________ ERROR at setup of TestAuthEndpoints.test_test_endpoint ____________

self = <sqlalchemy.engine.base.Connection object at 0x718db05ae0d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_______ ERROR at setup of TestAuthEndpoints.test_demo_protected_endpoint _______

self = <sqlalchemy.engine.base.Connection object at 0x718db0586b50>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestAuthEndpoints.test_demo_protected_endpoint_unauthenticated _

self = <sqlalchemy.engine.base.Connection object at 0x718db0e82610>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestDatabaseConnection.test_database_session_creation ____

self = <sqlalchemy.engine.base.Connection object at 0x718db053fb10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestDatabaseConnection.test_database_transaction_rollback __

self = <sqlalchemy.engine.base.Connection object at 0x718db00b4a50>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestUserDatabaseOperations.test_create_user_with_relationships _

self = <sqlalchemy.engine.base.Connection object at 0x718db0100e90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
__ ERROR at setup of TestUserDatabaseOperations.test_user_unique_constraints ___

self = <sqlalchemy.engine.base.Connection object at 0x718db0071390>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestUserDatabaseOperations.test_user_cascade_delete _____

self = <sqlalchemy.engine.base.Connection object at 0x718db00753d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoDatabaseOperations.test_create_photo_with_metadata _

self = <sqlalchemy.engine.base.Connection object at 0x718db0078cd0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoDatabaseOperations.test_photo_collaborator_relationships _

self = <sqlalchemy.engine.base.Connection object at 0x718db007d310>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoDatabaseOperations.test_photo_interaction_tracking _

self = <sqlalchemy.engine.base.Connection object at 0x718db01369d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
__ ERROR at setup of TestDatabasePerformance.test_user_photo_query_efficiency __

self = <sqlalchemy.engine.base.Connection object at 0x718db1dfa910>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestDatabasePerformance.test_photo_search_with_indexes ___

self = <sqlalchemy.engine.base.Connection object at 0x718db00ffa10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_photo_service_with_valid_ids _

self = <sqlalchemy.engine.base.Connection object at 0x718db0f5c710>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_photo_service_with_invalid_firebase_uid _

self = <sqlalchemy.engine.base.Connection object at 0x718db00dea10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_photo_service_with_invalid_photo_id _

self = <sqlalchemy.engine.base.Connection object at 0x718db0ef2dd0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_ensure_user_exists_with_valid_uid _

self = <sqlalchemy.engine.base.Connection object at 0x718db006b4d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_ensure_user_exists_with_invalid_uid _

self = <sqlalchemy.engine.base.Connection object at 0x718db18ebad0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_normalize_user_id_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db05def90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_normalize_photo_id_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db0e4f810>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_generate_storage_paths_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db00f8350>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_parse_storage_path_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db05b8dd0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestIDManagementServiceIntegration.test_prepare_ids_for_operation_integration _

self = <sqlalchemy.engine.base.Connection object at 0x718db0080cd0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestEndToEndPhotoFlow.test_complete_photo_upload_flow ____

self = <sqlalchemy.engine.base.Connection object at 0x718db0ec57d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestEndToEndPhotoFlow.test_photo_retrieval_with_id_validation _

self = <sqlalchemy.engine.base.Connection object at 0x718db1a02090>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestEndToEndPhotoFlow.test_invalid_id_formats_rejected_in_flow _

self = <sqlalchemy.engine.base.Connection object at 0x718db9b4a010>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestPhotoEndpoints.test_get_recent_photos_empty _______

self = <sqlalchemy.engine.base.Connection object at 0x718db9b2e290>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoEndpoints.test_get_recent_photos_with_pagination __

self = <sqlalchemy.engine.base.Connection object at 0x718db9b0e990>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoEndpoints.test_get_recent_photos_invalid_pagination _

self = <sqlalchemy.engine.base.Connection object at 0x718db9baebd0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_list_photos_public_endpoint _____

self = <sqlalchemy.engine.base.Connection object at 0x718db9b26e90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_______ ERROR at setup of TestPhotoEndpoints.test_get_nonexistent_photo ________

self = <sqlalchemy.engine.base.Connection object at 0x718db9b46d10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_get_my_photos_authenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db9af23d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestPhotoEndpoints.test_get_my_photos_unauthenticated ____

self = <sqlalchemy.engine.base.Connection object at 0x718db9b61f90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestPhotoEndpoints.test_get_user_photos_endpoint ______

self = <sqlalchemy.engine.base.Connection object at 0x718db9b11510>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestPhotoEndpoints.test_get_specific_user_photos ______

self = <sqlalchemy.engine.base.Connection object at 0x718db9b8ccd0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
________ ERROR at setup of TestPhotoEndpoints.test_upload_photo_success ________

self = <sqlalchemy.engine.base.Connection object at 0x718db9b98e50>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_upload_photo_unauthenticated ____

self = <sqlalchemy.engine.base.Connection object at 0x718db9b20d90>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
______ ERROR at setup of TestPhotoEndpoints.test_upload_invalid_file_type ______

self = <sqlalchemy.engine.base.Connection object at 0x718db9b59210>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_____ ERROR at setup of TestPhotoEndpoints.test_update_photo_authenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db05c3e50>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_update_photo_unauthenticated ____

self = <sqlalchemy.engine.base.Connection object at 0x718db0fe1790>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_____ ERROR at setup of TestPhotoEndpoints.test_delete_photo_authenticated _____

self = <sqlalchemy.engine.base.Connection object at 0x718db1c3fb10>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
____ ERROR at setup of TestPhotoEndpoints.test_delete_photo_unauthenticated ____

self = <sqlalchemy.engine.base.Connection object at 0x718db9ba7010>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_____ ERROR at setup of TestPhotoEndpoints.test_like_photo_not_implemented _____

self = <sqlalchemy.engine.base.Connection object at 0x718db0f4b390>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___ ERROR at setup of TestPhotoEndpoints.test_search_photos_not_implemented ____

self = <sqlalchemy.engine.base.Connection object at 0x718db18e8590>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_________ ERROR at setup of TestUserDeletion.test_get_deletion_summary _________

self = <integration.test_user_deletion.TestUserDeletion object at 0x718db2fd0190>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
_____ ERROR at setup of TestUserDeletion.test_delete_user_account_success ______

self = <integration.test_user_deletion.TestUserDeletion object at 0x718db2fd0850>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
_____ ERROR at setup of TestUserDeletion.test_deletion_with_storage_errors _____

self = <integration.test_user_deletion.TestUserDeletion object at 0x718db2fd1610>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
____ ERROR at setup of TestUserDeletion.test_deletion_rollback_on_db_error _____

self = <integration.test_user_deletion.TestUserDeletion object at 0x718db2fc5210>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
______ ERROR at setup of test_delete_user_endpoint_requires_confirmation _______

self = <sqlalchemy.engine.base.Connection object at 0x718db201a850>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
__________ ERROR at setup of TestPhotoModel.test_photo_model_creation __________

self = <sqlalchemy.engine.base.Connection object at 0x718db0ec7510>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
__________ ERROR at setup of TestPhotoModel.test_photo_default_values __________

self = <sqlalchemy.engine.base.Connection object at 0x718db2c6eed0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_______________ ERROR at setup of TestPhotoModel.test_photo_repr _______________

self = <sqlalchemy.engine.base.Connection object at 0x718db05b94d0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___________ ERROR at setup of TestUserModel.test_user_model_creation ___________

self = <sqlalchemy.engine.base.Connection object at 0x718db9af7950>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
___________ ERROR at setup of TestUserModel.test_user_default_values ___________

self = <sqlalchemy.engine.base.Connection object at 0x718db2c24cd0>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
________________ ERROR at setup of TestUserModel.test_user_repr ________________

self = <sqlalchemy.engine.base.Connection object at 0x718db2c01490>
engine = Engine(postgresql://postgres:***@localhost:5432/lumen_test)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError

The above exception was the direct cause of the following exception:

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/conftest.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/schema.py:5828: in create_all
    bind._run_ddl_visitor(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3242: in _run_ddl_visitor
    with self.begin() as conn:
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3232: in begin
    with self.connect() as conn:
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3268: in connect
    return self._connection_cls(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:147: in __init__
    Connection._handle_dbapi_exception_noconnection(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2430: in _handle_dbapi_exception_noconnection
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:145: in __init__
    self._dbapi_connection = engine.raw_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3292: in raw_connection
    return self.pool.connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:452: in connect
    return _ConnectionFairy._checkout(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1269: in _checkout
    fairy = _ConnectionRecord.checkout(pool)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:716: in checkout
    rec = pool._do_get()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:169: in _do_get
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/impl.py:167: in _do_get
    return self._create_connection()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:393: in _create_connection
    return _ConnectionRecord(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:678: in __init__
    self.__connect()
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:902: in __connect
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/pool/base.py:898: in __connect
    self.dbapi_connection = connection = pool._invoke_creator(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/create.py:637: in connect
    return dialect.connect(*cargs, **cparams)
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:616: in connect
    return self.loaded_dbapi.connect(*cargs, **cparams)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'host=localhost dbname=lumen_test user=postgres port=5432'
connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'lumen_test', 'host': 'localhost', 'port': 5432, 'user': 'postgres'}
kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
>       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       sqlalchemy.exc.OperationalError: (psycopg2.OperationalError) connection to server at "localhost" (127.0.0.1), port 5432 failed: fe_sendauth: no password supplied
E       
E       (Background on this error at: https://sqlalche.me/e/20/e3q8)

backend/venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError
_ ERROR at setup of TestPhotoServiceIDValidation.test_photo_service_with_valid_ids _

self = <tests.integration.test_id_validation_integration.TestPhotoServiceIDValidation object at 0x718db2e5cfd0>

>   ???
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for CreatePhotoRequest
E   image_url
E     Field required [type=missing, input_value={'title': 'Test Photo', '..., 'is_portfolio': False}, input_type=dict]
E       For further information visit https://errors.pydantic.dev/2.5/v/missing

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_id_validation_integration.py:115: ValidationError
_ ERROR at setup of TestPhotoServiceIDValidation.test_photo_service_with_invalid_firebase_uid _

self = <tests.integration.test_id_validation_integration.TestPhotoServiceIDValidation object at 0x718db2e39750>

>   ???
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for CreatePhotoRequest
E   image_url
E     Field required [type=missing, input_value={'title': 'Test Photo', '..., 'is_portfolio': False}, input_type=dict]
E       For further information visit https://errors.pydantic.dev/2.5/v/missing

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_id_validation_integration.py:115: ValidationError
_________ ERROR at setup of TestUserDeletion.test_get_deletion_summary _________

self = <tests.integration.test_user_deletion.TestUserDeletion object at 0x718db2e97050>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
_____ ERROR at setup of TestUserDeletion.test_delete_user_account_success ______

self = <tests.integration.test_user_deletion.TestUserDeletion object at 0x718db2e976d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
_____ ERROR at setup of TestUserDeletion.test_deletion_with_storage_errors _____

self = <tests.integration.test_user_deletion.TestUserDeletion object at 0x718db2e9c450>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
____ ERROR at setup of TestUserDeletion.test_deletion_rollback_on_db_error _____

self = <tests.integration.test_user_deletion.TestUserDeletion object at 0x718db2e9cad0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_user_deletion.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Photo(id='photo_1', title='Test Photo 1', user='Unknown')>
kwargs = {'id': 'photo_1', 'storage_path': 'photos/test_user_123/photo_1.jpg', 'title': 'Test Photo 1', 'user_id': 'test_user_123'}
cls_ = <class 'app.models.photo.Photo'>, k = 'storage_path'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'storage_path' is an invalid keyword argument for Photo

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
=================================== FAILURES ===================================
______________ TestAuthEndpoints.test_auth_status_unauthenticated ______________

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db32a1850>
client = <starlette.testclient.TestClient object at 0x718db2daf9d0>

>   ???
E   assert 404 == 200
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:21: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/auth/status "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/auth/status "HTTP/1.1 404 Not Found"
_______________ TestAuthEndpoints.test_auth_status_authenticated _______________

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db3183a50>
mock_get_user = <AsyncMock name='get_optional_user' id='124853395011600'>
client = <starlette.testclient.TestClient object at 0x718db24229d0>

>   ???
E   assert 404 == 200
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:40: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/auth/status "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/auth/status "HTTP/1.1 404 Not Found"
______________ TestAuthEndpoints.test_get_profile_unauthenticated ______________

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db31941d0>
client = <starlette.testclient.TestClient object at 0x718db2460a90>

>   ???
E   assert 404 == 401
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:49: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/auth/profile "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/auth/profile "HTTP/1.1 404 Not Found"
_______________ TestAuthEndpoints.test_get_profile_authenticated _______________

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db3194510>
mock_get_user = <AsyncMock name='get_current_user' id='124853395248592'>
client = <starlette.testclient.TestClient object at 0x718db24638d0>

>   ???
E   assert 404 == 200
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:65: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/auth/profile "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/auth/profile "HTTP/1.1 404 Not Found"
____________________ TestAuthEndpoints.test_logout_endpoint ____________________

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db3194910>
client = <starlette.testclient.TestClient object at 0x718db2460690>

>   ???
E   assert 404 == 200
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:74: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: POST http://testserver/api/auth/logout "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: POST http://testserver/api/auth/logout "HTTP/1.1 404 Not Found"
_____________________ TestAuthEndpoints.test_test_endpoint _____________________

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db3194fd0>
client = <starlette.testclient.TestClient object at 0x718db2464a90>

>   ???
E   assert 404 == 200
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:81: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/auth/test "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/auth/test "HTTP/1.1 404 Not Found"
________________ TestAuthEndpoints.test_demo_protected_endpoint ________________

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db31956d0>
mock_get_user = <AsyncMock name='get_current_user' id='124853395260048'>
client = <starlette.testclient.TestClient object at 0x718db2462950>

>   ???
E   assert 404 == 200
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:94: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/auth/demo "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/auth/demo "HTTP/1.1 404 Not Found"
________ TestAuthEndpoints.test_demo_protected_endpoint_unauthenticated ________

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db3195e50>
client = <starlette.testclient.TestClient object at 0x718db2478b90>

>   ???
E   assert 404 == 401
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:102: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/auth/demo "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/auth/demo "HTTP/1.1 404 Not Found"
___________ TestAuthEndpoints.test_check_registration_existing_user ____________

self = <sqlalchemy.engine.base.Connection object at 0x718db2364d50>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db4b21c90>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db2366f50>
parameters = [{'age': None, 'availability_data': '{}', 'bio': None, 'birth_date': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236dc60; closed: -1>
statement = 'INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepte...ier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active'
parameters = {'age': None, 'availability_data': '{}', 'bio': None, 'birth_date': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db4b21c90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.NotNullViolation: null value in column "handle" of relation "users" violates not-null constraint
E       DETAIL:  Failing row contains (test-existing-uid, existing@example.com, null, Existing User, 1, 1, null, null, null, null, null, null, null, null, f, f, null, null, null, {}, {}, {"show_age": true, "show_city": false, "show_country": true}, 2025-09-21 03:59:08.950622, 2025-09-21 03:59:08.950622, 2025-09-21 03:59:08.950622, null, null, null, null, null, null, free, active, {}).

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: NotNullViolation

The above exception was the direct cause of the following exception:

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db3196b90>
mock_get_user = <AsyncMock name='get_current_user' id='124853395364432'>
client = <starlette.testclient.TestClient object at 0x718db2423e10>
db_session = <sqlalchemy.orm.session.Session object at 0x718db2421c10>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236dc60; closed: -1>
statement = 'INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepte...ier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active'
parameters = {'age': None, 'availability_data': '{}', 'bio': None, 'birth_date': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db4b21c90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (psycopg2.errors.NotNullViolation) null value in column "handle" of relation "users" violates not-null constraint
E       DETAIL:  Failing row contains (test-existing-uid, existing@example.com, null, Existing User, 1, 1, null, null, null, null, null, null, null, null, f, f, null, null, null, {}, {}, {"show_age": true, "show_city": false, "show_country": true}, 2025-09-21 03:59:08.950622, 2025-09-21 03:59:08.950622, 2025-09-21 03:59:08.950622, null, null, null, null, null, null, free, active, {}).
E       
E       [SQL: INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepted_at, gender, age, height_cm, weight_kg, ethnicity, eye_color, hair_color, has_tattoos, has_piercings, profile_image_url, bio, website, profile_data, availability_data, privacy_settings, stripe_customer_id, stripe_subscription_id, subscription_tier, subscription_status, subscription_data) VALUES (%(id)s, %(email)s, %(handle)s, %(display_name)s, %(city_id)s, %(primary_user_type)s, %(birth_date)s, %(country_code)s, %(tos_accepted_at)s, %(gender)s, %(age)s, %(height_cm)s, %(weight_kg)s, %(ethnicity)s, %(eye_color)s, %(hair_color)s, %(has_tattoos)s, %(has_piercings)s, %(profile_image_url)s, %(bio)s, %(website)s, %(profile_data)s, %(availability_data)s, %(privacy_settings)s, %(stripe_customer_id)s, %(stripe_subscription_id)s, %(subscription_tier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active]
E       [parameters: {'id': 'test-existing-uid', 'email': 'existing@example.com', 'handle': None, 'display_name': 'Existing User', 'city_id': 1, 'primary_user_type': 1, 'birth_date': None, 'country_code': None, 'tos_accepted_at': None, 'gender': None, 'age': None, 'height_cm': None, 'weight_kg': None, 'ethnicity': None, 'eye_color': None, 'hair_color': None, 'has_tattoos': False, 'has_piercings': False, 'profile_image_url': None, 'bio': None, 'website': None, 'profile_data': '{}', 'availability_data': '{}', 'privacy_settings': '{"show_city": false, "show_country": true, "show_age": true}', 'stripe_customer_id': None, 'stripe_subscription_id': None, 'subscription_tier': 'free', 'subscription_status': 'active', 'subscription_data': '{}'}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: IntegrityError
______________ TestAuthEndpoints.test_check_registration_new_user ______________

self = <tests.test_auth_endpoints.TestAuthEndpoints object at 0x718db3197250>
mock_get_user = <AsyncMock name='get_current_user' id='124853405008976'>
client = <starlette.testclient.TestClient object at 0x718db2dad150>
db_session = <sqlalchemy.orm.session.Session object at 0x718db2dace50>

>   ???
E   assert 404 == 200
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_endpoints.py:165: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/auth/check-registration "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/auth/check-registration "HTTP/1.1 404 Not Found"
_ TestAuthMiddlewareIntegration.test_middleware_with_fastapi_dependency_injection _

self = <tests.test_auth_middleware.TestAuthMiddlewareIntegration object at 0x718db31aaa50>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_auth_middleware.py:263: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/protected "HTTP/1.1 403 Forbidden"
INFO:httpx:HTTP Request: GET http://testserver/optional "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/protected "HTTP/1.1 403 Forbidden"
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/optional "HTTP/1.1 403 Forbidden"
__________________ TestPhotoEndpoints.test_get_recent_photos ___________________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31c96d0>
client = <starlette.testclient.TestClient object at 0x718db23e7110>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db23e6d90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'get_recent_photos'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestPhotoEndpoints.test_list_photos_with_pagination ______________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31c9d90>
client = <starlette.testclient.TestClient object at 0x718db23e44d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db23e7590>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'list_photos'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestPhotoEndpoints.test_upload_photo_authenticated ______________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31ca3d0>
mock_get_user = <AsyncMock name='get_current_user' id='124853380320528'>
client = <starlette.testclient.TestClient object at 0x718db16205d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db1623610>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'create_photo'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
_____________ TestPhotoEndpoints.test_upload_photo_unauthenticated _____________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31caad0>
client = <starlette.testclient.TestClient object at 0x718db2da0c10>

>   ???
E   assert 404 == 401
E    +  where 404 = <Response [404 Not Found]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:96: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: POST http://testserver/api/photos/upload "HTTP/1.1 404 Not Found"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: POST http://testserver/api/photos/upload "HTTP/1.1 404 Not Found"
____________________ TestPhotoEndpoints.test_get_my_photos _____________________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31cb110>
mock_get_user = <AsyncMock name='get_current_user' id='124853394765072'>
client = <starlette.testclient.TestClient object at 0x718db1c84990>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db22d0090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'get_user_photos'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestPhotoEndpoints.test_get_photo_by_id ____________________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31cb7d0>
client = <starlette.testclient.TestClient object at 0x718db1992e50>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db2153e90>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'get_photo_by_id'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
_________________ TestPhotoEndpoints.test_get_photo_not_found __________________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31cbe90>
client = <starlette.testclient.TestClient object at 0x718db1c84910>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db2268110>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'get_photo_by_id'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestPhotoEndpoints.test_update_photo_owner __________________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31caf10>
mock_get_user = <AsyncMock name='get_current_user' id='124853385712336'>
client = <starlette.testclient.TestClient object at 0x718db1b44050>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:152: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db1b47a10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'get_photo_by_id'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
__________________ TestPhotoEndpoints.test_delete_photo_owner __________________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31b14d0>
mock_get_user = <AsyncMock name='get_current_user' id='124853388719120'>
client = <starlette.testclient.TestClient object at 0x718db19d0b90>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:178: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db1e22310>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'get_photo_by_id'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestPhotoEndpoints.test_delete_photo_not_owner ________________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31d0490>
mock_get_user = <AsyncMock name='get_current_user' id='124853380432144'>
client = <starlette.testclient.TestClient object at 0x718db22d0850>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db163d450>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'get_photo_by_id'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
______________________ TestPhotoEndpoints.test_like_photo ______________________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31d07d0>
mock_get_user = <AsyncMock name='get_current_user' id='124853387020816'>
client = <starlette.testclient.TestClient object at 0x718db1c87290>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db1c87850>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'toggle_like'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestPhotoEndpoints.test_search_photos _____________________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31d0b10>
client = <starlette.testclient.TestClient object at 0x718db163e490>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db211c950>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'search_photos'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
______________ TestPhotoEndpoints.test_get_user_photos_by_handle _______________

self = <tests.test_photo_endpoints.TestPhotoEndpoints object at 0x718db31d0e50>
client = <starlette.testclient.TestClient object at 0x718db2d9a410>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_endpoints.py:244: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db2d99190>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.photo_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/photo_service.py'> does not have the attribute 'get_photos_by_user_handle'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
___________________ TestPhotoModel.test_photo_model_creation ___________________

self = <sqlalchemy.engine.base.Connection object at 0x718db31caa50>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db22d2610>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db1e6df50>
parameters = [{'camera_data': '{"make": "Canon", "model": "EOS R5", "settings": {"iso": 100, "aperture": 2.8, "shutter": "1/60", "focal_length": 50}}', 'category': 'portrait', 'city_id': None, 'content_rating': 'general', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236f5b0; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, camera_data, u..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'camera_data': '{"make": "Canon", "model": "EOS R5", "settings": {"iso": 100, "aperture": 2.8, "shutter": "1/60", "focal_length": 50}}', 'category': 'portrait', 'city_id': None, 'content_rating': 'general', ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db22d2610>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DatatypeMismatch: column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ...rtrait','studio']::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: DatatypeMismatch

The above exception was the direct cause of the following exception:

self = <tests.test_photo_model.TestPhotoModel object at 0x718db31e82d0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db21513d0>
sample_photo_data = {'camera_data': {'make': 'Canon', 'model': 'EOS R5', 'settings': {'aperture': 2.8, 'focal_length': 50, 'iso': 100, 'sh...scription': 'A test photo for unit testing', 'image_url': 'https://example.com/test-photo.jpg', 'is_public': True, ...}

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_model.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236f5b0; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, camera_data, u..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'camera_data': '{"make": "Canon", "model": "EOS R5", "settings": {"iso": 100, "aperture": 2.8, "shutter": "1/60", "focal_length": 50}}', 'category': 'portrait', 'city_id': None, 'content_rating': 'general', ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db22d2610>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DatatypeMismatch) column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ...rtrait','studio']::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.
E       
E       [SQL: INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, camera_data, user_tags, content_rating, category, series_id, is_deleted, is_public, view_count, is_collaborative, model_release_status, extra_metadata, is_portfolio, status) VALUES (%(id)s::UUID, %(user_id)s, %(title)s, %(description)s, %(image_url)s, %(thumbnail_url)s, %(city_id)s, %(location_name)s, %(camera_data)s, %(user_tags)s::TEXT[], %(content_rating)s, %(category)s, %(series_id)s::UUID, %(is_deleted)s, %(is_public)s, %(view_count)s, %(is_collaborative)s, %(model_release_status)s, %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at]
E       [parameters: {'id': UUID('46685dd9-3bc1-4751-8a8d-bc485a352596'), 'user_id': UUID('999a6c9b-07b3-43a1-90e6-2a1da3cd0cae'), 'title': 'Test Photo', 'description': 'A test photo for unit testing', 'image_url': None, 'thumbnail_url': None, 'city_id': None, 'location_name': None, 'camera_data': '{"make": "Canon", "model": "EOS R5", "settings": {"iso": 100, "aperture": 2.8, "shutter": "1/60", "focal_length": 50}}', 'user_tags': ['portrait', 'studio'], 'content_rating': 'general', 'category': 'portrait', 'series_id': None, 'is_deleted': False, 'is_public': True, 'view_count': 0, 'is_collaborative': False, 'model_release_status': 'none', 'extra_metadata': '{}', 'is_portfolio': False, 'status': 'active'}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: ProgrammingError
___________________ TestPhotoModel.test_photo_default_values ___________________

self = <sqlalchemy.engine.base.Connection object at 0x718db1e39d50>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1e39ed0>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db1e384d0>
parameters = [{'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236dd50; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1e39ed0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DatatypeMismatch: column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ... NULL, NULL, NULL::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: DatatypeMismatch

The above exception was the direct cause of the following exception:

self = <tests.test_photo_model.TestPhotoModel object at 0x718db31e89d0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db2d9aad0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_model.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236dd50; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1e39ed0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DatatypeMismatch) column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ... NULL, NULL, NULL::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.
E       
E       [SQL: INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, content_rating, category, series_id, is_deleted, is_public, view_count, is_collaborative, model_release_status, extra_metadata, is_portfolio, status) VALUES (%(id)s::UUID, %(user_id)s, %(title)s, %(description)s, %(image_url)s, %(thumbnail_url)s, %(city_id)s, %(location_name)s, %(user_tags)s::TEXT[], %(content_rating)s, %(category)s, %(series_id)s::UUID, %(is_deleted)s, %(is_public)s, %(view_count)s, %(is_collaborative)s, %(model_release_status)s, %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at]
E       [parameters: {'id': UUID('27be81ec-a448-4574-8688-92818cd347b3'), 'user_id': UUID('399b42a7-dc54-41e0-a49e-2461e15f92bd'), 'title': None, 'description': None, 'image_url': None, 'thumbnail_url': None, 'city_id': None, 'location_name': None, 'user_tags': None, 'content_rating': 'general', 'category': 'portrait', 'series_id': None, 'is_deleted': False, 'is_public': True, 'view_count': 0, 'is_collaborative': False, 'model_release_status': 'none', 'extra_metadata': '{}', 'is_portfolio': False, 'status': 'active'}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: ProgrammingError
________________________ TestPhotoModel.test_photo_repr ________________________

self = <sqlalchemy.engine.base.Connection object at 0x718db1887e50>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1884610>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db1e384d0>
parameters = [{'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236fb50; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1884610>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DatatypeMismatch: column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ... NULL, NULL, NULL::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: DatatypeMismatch

The above exception was the direct cause of the following exception:

self = <tests.test_photo_model.TestPhotoModel object at 0x718db31e90d0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db2153890>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_model.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236fb50; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1884610>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DatatypeMismatch) column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ... NULL, NULL, NULL::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.
E       
E       [SQL: INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, content_rating, category, series_id, is_deleted, is_public, view_count, is_collaborative, model_release_status, extra_metadata, is_portfolio, status) VALUES (%(id)s::UUID, %(user_id)s, %(title)s, %(description)s, %(image_url)s, %(thumbnail_url)s, %(city_id)s, %(location_name)s, %(user_tags)s::TEXT[], %(content_rating)s, %(category)s, %(series_id)s::UUID, %(is_deleted)s, %(is_public)s, %(view_count)s, %(is_collaborative)s, %(model_release_status)s, %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at]
E       [parameters: {'id': UUID('e08bf1fd-293d-4862-96be-8ada75b6b722'), 'user_id': UUID('364a0442-bcbf-42c0-b13a-0af5225fd1a4'), 'title': 'Test Photo', 'description': None, 'image_url': None, 'thumbnail_url': None, 'city_id': None, 'location_name': None, 'user_tags': None, 'content_rating': 'general', 'category': 'portrait', 'series_id': None, 'is_deleted': False, 'is_public': True, 'view_count': 0, 'is_collaborative': False, 'model_release_status': 'none', 'extra_metadata': '{}', 'is_portfolio': False, 'status': 'active'}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: ProgrammingError
___________________ TestPhotoModel.test_like_count_property ____________________

self = <tests.test_photo_model.TestPhotoModel object at 0x718db31e97d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_model.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db24caa50>
child = <Mock id='124853373865104'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245dd80>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853373866896'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
_______________ TestPhotoModel.test_collaborator_names_property ________________

self = <tests.test_photo_model.TestPhotoModel object at 0x718db31e9e90>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_model.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db160e510>
child = <Mock id='124853393721680'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245e900>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853393721872'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
_____ TestPhotoModel.test_photographer_name_property_owner_is_photographer _____

self = <tests.test_photo_model.TestPhotoModel object at 0x718db31d0990>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_model.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1bcc2f0>
child = <Mock id='124853388812944'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24d2dc0>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853388813136'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_ TestPhotoModel.test_photographer_name_property_collaborator_is_photographer __

self = <tests.test_photo_model.TestPhotoModel object at 0x718db31e9e50>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_model.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1bcc230>
child = <Mock id='124853387028560'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24d2dc0>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853387022928'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
________________ TestPhotoModel.test_location_display_property _________________

self = <tests.test_photo_model.TestPhotoModel object at 0x718db31ea110>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_model.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1bce810>
child = <Mock id='124853404880080'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24e4e00>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853404879568'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
____________________ TestPhotoModel.test_is_liked_by_method ____________________

self = <tests.test_photo_model.TestPhotoModel object at 0x718db31ead10>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_photo_model.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1bce090>
child = <Mock id='124853376872528'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245dd80>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853376867408'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
____________________ TestUserModel.test_user_model_creation ____________________

self = <tests.test_user_model.TestUserModel object at 0x718db31f6250>
db_session = <sqlalchemy.orm.session.Session object at 0x718db164b610>
sample_user_data = {'bio': 'Test photographer', 'birth_date': datetime.date(1990, 1, 1), 'city_id': 1, 'country_code': 'US', ...}

>   ???
E   KeyError: 'firebase_uid'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_model.py:27: KeyError
____________________ TestUserModel.test_user_default_values ____________________

self = <sqlalchemy.engine.base.Connection object at 0x718db2114050>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db2114410>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db2366f50>
parameters = [{'age': None, 'availability_data': '{}', 'bio': None, 'birth_date': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236f4c0; closed: -1>
statement = 'INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepte...ier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active'
parameters = {'age': None, 'availability_data': '{}', 'bio': None, 'birth_date': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db2114410>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "users_email_key"
E       DETAIL:  Key (email)=(defaults@example.com) already exists.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: UniqueViolation

The above exception was the direct cause of the following exception:

self = <tests.test_user_model.TestUserModel object at 0x718db31f5a90>
db_session = <sqlalchemy.orm.session.Session object at 0x718db21159d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_model.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db236f4c0; closed: -1>
statement = 'INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepte...ier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active'
parameters = {'age': None, 'availability_data': '{}', 'bio': None, 'birth_date': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db2114410>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (psycopg2.errors.UniqueViolation) duplicate key value violates unique constraint "users_email_key"
E       DETAIL:  Key (email)=(defaults@example.com) already exists.
E       
E       [SQL: INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepted_at, gender, age, height_cm, weight_kg, ethnicity, eye_color, hair_color, has_tattoos, has_piercings, profile_image_url, bio, website, profile_data, availability_data, privacy_settings, stripe_customer_id, stripe_subscription_id, subscription_tier, subscription_status, subscription_data) VALUES (%(id)s, %(email)s, %(handle)s, %(display_name)s, %(city_id)s, %(primary_user_type)s, %(birth_date)s, %(country_code)s, %(tos_accepted_at)s, %(gender)s, %(age)s, %(height_cm)s, %(weight_kg)s, %(ethnicity)s, %(eye_color)s, %(hair_color)s, %(has_tattoos)s, %(has_piercings)s, %(profile_image_url)s, %(bio)s, %(website)s, %(profile_data)s, %(availability_data)s, %(privacy_settings)s, %(stripe_customer_id)s, %(stripe_subscription_id)s, %(subscription_tier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active]
E       [parameters: {'id': 'test-uid-defaults', 'email': 'defaults@example.com', 'handle': 'defaultuser', 'display_name': 'Default User', 'city_id': 1, 'primary_user_type': 1, 'birth_date': None, 'country_code': None, 'tos_accepted_at': None, 'gender': None, 'age': None, 'height_cm': None, 'weight_kg': None, 'ethnicity': None, 'eye_color': None, 'hair_color': None, 'has_tattoos': False, 'has_piercings': False, 'profile_image_url': None, 'bio': None, 'website': None, 'profile_data': '{}', 'availability_data': '{}', 'privacy_settings': '{"show_city": false, "show_country": true, "show_age": true}', 'stripe_customer_id': None, 'stripe_subscription_id': None, 'subscription_tier': 'free', 'subscription_status': 'active', 'subscription_data': '{}'}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: IntegrityError
___________________ TestUserModel.test_user_type_properties ____________________

self = <tests.test_user_model.TestUserModel object at 0x718db31e8850>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_model.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1bd22d0>
child = <Mock id='124853393020752'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853393021328'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_______________ TestUserModel.test_location_display_with_privacy _______________

self = <tests.test_user_model.TestUserModel object at 0x718db3004b10>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_model.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1bd3230>
child = <Mock id='124853379470864'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2466d00>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853379470928'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_______________ TestUserModel.test_model_validation_requirements _______________

self = <tests.test_user_model.TestUserModel object at 0x718db30051d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_model.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1bd3d70>
child = <Mock id='124853404856336'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853404855696'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
___________ TestUserModel.test_photographer_validation_requirements ____________

self = <tests.test_user_model.TestUserModel object at 0x718db3005890>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_model.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1bd3170>
child = <Mock id='124853393732176'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853393731216'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_______________ TestUserPydanticModels.test_user_profile_models ________________

self = <tests.test_user_model.TestUserPydanticModels object at 0x718db3007450>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_model.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = UserProfilePrivate(id='test-user-id', handle='testuser', display_name='Test User', bio=None, profile_image_url=None, c...r_travel=False, location_preferences=[], website=None, email='test@example.com', privacy_settings={'show_city': False})
item = 'firebase_uid'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra is not None:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'UserProfilePrivate' object has no attribute 'firebase_uid'

backend/venv/lib/python3.11/site-packages/pydantic/main.py:761: AttributeError
________________ TestUserService.test_create_photographer_user _________________

self = <tests.test_user_service.TestUserService object at 0x718db300c890>
db_session = <sqlalchemy.orm.session.Session object at 0x718db0fc0f90>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db0fc34d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.user_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/user_service.py'> does not have the attribute 'get_db'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
____________________ TestUserService.test_create_model_user ____________________

self = <tests.test_user_service.TestUserService object at 0x718db300cc50>
db_session = <sqlalchemy.orm.session.Session object at 0x718db2127c50>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db2124090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.services.user_service' from '/home/cdc/Storage/NVMe/projects/lumen/backend/app/services/user_service.py'> does not have the attribute 'get_db'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
________________ TestUserService.test_get_user_by_firebase_uid _________________

self = <tests.test_user_service.TestUserService object at 0x718db300c0d0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db0fc3150>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'display_name': 'Test User', 'email': 'test@example.com', 'firebase_uid': 'test-uid-123', 'handle': 'testuser', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
___________________ TestUserService.test_get_user_by_handle ____________________

self = <tests.test_user_service.TestUserService object at 0x718db300e490>
db_session = <sqlalchemy.orm.session.Session object at 0x718db22eb650>

>   ???
E   TypeError: UserService.get_user_by_handle() takes 2 positional arguments but 3 were given

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:127: TypeError
___________________ TestUserService.test_update_user_profile ___________________

self = <tests.test_user_service.TestUserService object at 0x718db300e990>
db_session = <sqlalchemy.orm.session.Session object at 0x718db150eed0>

>   ???
E   TypeError: UserService.update_user_profile() takes 3 positional arguments but 4 were given

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:156: TypeError
_________________ TestUserService.test_validate_unique_handle __________________

self = <tests.test_user_service.TestUserService object at 0x718db300f090>
db_session = <sqlalchemy.orm.session.Session object at 0x718db21e75d0>

>   ???
E   AttributeError: 'UserService' object has no attribute 'is_handle_available'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:173: AttributeError
__________________ TestUserService.test_user_age_verification __________________

self = <tests.test_user_service.TestUserService object at 0x718db300f790>
db_session = <sqlalchemy.orm.session.Session object at 0x718db22ebed0>

>   ???
E   ImportError: cannot import name 'verify_age_compliance' from 'app.utils.age_verification' (/home/cdc/Storage/NVMe/projects/lumen/backend/app/utils/age_verification.py)

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:188: ImportError
________________ TestUserService.test_user_search_functionality ________________

self = <tests.test_user_service.TestUserService object at 0x718db300fe90>
db_session = <sqlalchemy.orm.session.Session object at 0x718db2d8e510>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: in _declarative_constructor
    setattr(self, k, kwargs[k])
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1669c10>
child = <UserType.PHOTOGRAPHER: 'photographer'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
>               instance_state(child),
                instance_dict(child),
            )
E           AttributeError: 'UserType' object has no attribute '_sa_instance_state'

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2168: AttributeError
_________________ TestUserService.test_user_profile_visibility _________________

self = <tests.test_user_service.TestUserService object at 0x718db30205d0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db1603650>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='testuser', display_name='Test User')>
kwargs = {'display_name': 'Test User', 'email': 'test@example.com', 'handle': 'testuser', 'id': 'test-uid', ...}
cls_ = <class 'app.models.user.User'>, k = 'profile_visibility'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'profile_visibility' is an invalid keyword argument for User

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2142: TypeError
________________ TestUserService.test_user_content_permissions _________________

self = <tests.test_user_service.TestUserService object at 0x718db3020c90>
db_session = <sqlalchemy.orm.session.Session object at 0x718db2d86910>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db2d87510>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <app.services.user_service.UserService object at 0x718db2d86710> does not have the attribute 'check_content_access'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
_____ TestUserModelIntegration.test_user_model_creation_with_relationships _____

self = <tests.test_user_service.TestUserModelIntegration object at 0x718db3021590>
db_session = <sqlalchemy.orm.session.Session object at 0x718db23e7090>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:294: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:3437: in add
    self._save_or_update_state(state)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:3461: in _save_or_update_state
    self._save_or_update_impl(state)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4162: in _save_or_update_impl
    self._update_impl(state)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4136: in _update_impl
    "to the transient state." % state_str(state)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/base.py:367: in state_str
    return "<%s at 0x%x>" % (state.class_.__name__, id(state.obj()))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Mock name='User()._sa_instance_state.class_' id='124853393672784'>
name = '__name__'

    def __getattr__(self, name):
        if name in {'_mock_methods', '_mock_unsafe'}:
            raise AttributeError(name)
        elif self._mock_methods is not None:
            if name not in self._mock_methods or name in _all_magics:
                raise AttributeError("Mock object has no attribute %r" % name)
        elif _is_magic(name):
>           raise AttributeError(name)
E           AttributeError: __name__

/usr/lib/python3.11/unittest/mock.py:655: AttributeError
____________ TestUserModelIntegration.test_user_cascade_operations _____________

self = <tests.test_user_service.TestUserModelIntegration object at 0x718db3021c90>
db_session = <sqlalchemy.orm.session.Session object at 0x718db164bf50>

>   ???
E   AttributeError: 'UserService' object has no attribute 'delete_user'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:309: AttributeError
__________ TestLiveSystemHealth.test_authenticated_endpoint_behavior ___________

self = <tests.diagnostics.test_live_system.TestLiveSystemHealth object at 0x718db3030f10>

>   ???
E   AssertionError: Should require authentication
E   assert 403 == 401
E    +  where 403 = <Response [403]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_live_system.py:140: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.diagnostics.test_live_system.TestLiveSystemHealth object at 0x718db3030f10>

>   ???
E   Failed: Authentication test failed: Should require authentication
E   assert 403 == 401
E    +  where 403 = <Response [403]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_live_system.py:155: Failed
----------------------------- Captured stdout call -----------------------------
My-photos without auth: 403
__________ TestPhotoDisplayPipeline.test_photo_service_initialization __________

self = <tests.diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db300ef10>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/app/services/photo_service.py:24: in __init__
    self.storage = get_storage_backend()
backend/app/storage/__init__.py:39: in get_storage_backend
    _storage_instance = _create_local_storage()
backend/app/storage/__init__.py:57: in _create_local_storage
    return LocalStorageService(
backend/app/storage/local_storage.py:87: in __init__
    asyncio.create_task(self._initialize_directories())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

coro = <coroutine object LocalStorageService._initialize_directories at 0x718db70a2bd0>

    def create_task(coro, *, name=None, context=None):
        """Schedule the execution of a coroutine object in a spawn task.
    
        Return a Task object.
        """
>       loop = events.get_running_loop()
E       RuntimeError: no running event loop

/usr/lib/python3.11/asyncio/tasks.py:381: RuntimeError

During handling of the above exception, another exception occurred:

self = <tests.diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db300ef10>

>   ???
E   Failed: PhotoService initialization failed: no running event loop

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:91: Failed
----------------------------- Captured stderr call -----------------------------
INFO:app.storage.image_processor:ImageProcessor initialized with WebP: True, HEIF: False, Thread pool: 2
------------------------------ Captured log call -------------------------------
INFO     app.storage.image_processor:image_processor.py:91 ImageProcessor initialized with WebP: True, HEIF: False, Thread pool: 2
_____________ TestPhotoDisplayPipeline.test_signed_url_generation ______________

args = (<tests.diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db303eb50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.photo_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.photo_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestPhotoDisplayPipeline.test_photo_service_recent_photos ___________

self = <tests.diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db303f7d0>

>   ???
E   AttributeError: 'coroutine' object has no attribute 'photos'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:195: AttributeError

During handling of the above exception, another exception occurred:

self = <tests.diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db303f7d0>

>   ???
E   Failed: PhotoService.get_recent_photos failed: 'coroutine' object has no attribute 'photos'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:206: Failed
----------------------------- Captured stdout call -----------------------------
 PhotoService.get_recent_photos working
____________ TestAuthenticationFlow.test_firebase_token_validation _____________

args = (<tests.diagnostics.test_photo_pipeline.TestAuthenticationFlow object at 0x718db3048910>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.auth_middleware.firebase_admin.auth'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.auth_middleware' has no attribute 'firebase_admin'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestAuthenticationFlow.test_auth_middleware_error_handling __________

self = <tests.diagnostics.test_photo_pipeline.TestAuthenticationFlow object at 0x718db3048fd0>

>   ???
E   AssertionError: Should require authentication
E   assert 403 == 401
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:264: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
_________ TestExternalServiceIntegration.test_gcs_bucket_accessibility _________

self = <tests.diagnostics.test_photo_pipeline.TestExternalServiceIntegration object at 0x718db3049890>

>   ???
E   AssertionError: Bucket lumen-photos-20250731 should exist
E   assert False
E    +  where False = <bound method Bucket.exists of <Bucket: lumen-photos-20250731>>()
E    +    where <bound method Bucket.exists of <Bucket: lumen-photos-20250731>> = <Bucket: lumen-photos-20250731>.exists

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:292: AssertionError

During handling of the above exception, another exception occurred:

self = <tests.diagnostics.test_photo_pipeline.TestExternalServiceIntegration object at 0x718db3049890>

>   ???
E   Failed: GCS bucket accessibility test failed: Bucket lumen-photos-20250731 should exist
E   assert False
E    +  where False = <bound method Bucket.exists of <Bucket: lumen-photos-20250731>>()
E    +    where <bound method Bucket.exists of <Bucket: lumen-photos-20250731>> = <Bucket: lumen-photos-20250731>.exists

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:300: Failed
_ TestAuthMiddlewareIntegration.test_middleware_with_fastapi_dependency_injection _

self = <test_auth_middleware.TestAuthMiddlewareIntegration object at 0x718db3071fd0>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_auth_middleware.py:263: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/protected "HTTP/1.1 403 Forbidden"
INFO:httpx:HTTP Request: GET http://testserver/optional "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/protected "HTTP/1.1 403 Forbidden"
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/optional "HTTP/1.1 403 Forbidden"
_________ TestIDValidationIntegration.test_valid_firebase_uid_formats __________

self = <test_id_validation_integration.TestIDValidationIntegration object at 0x718db30971d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_id_validation_integration.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = 'abcd1234efgh5678ijkl9012mnop3456'
context = 'test valid UID: abcd1234efgh5678ijkl9012mnop3456'

    def validate_firebase_uid(value: any, context: str = "") -> FirebaseUID:
        """
        Validate and return a Firebase UID, raising exception if invalid
    
        In TEST_MODE, also accepts UUID format and test ID patterns for test users
    
        Args:
            value: Value to validate as Firebase UID
            context: Additional context for error messages
    
        Returns:
            Validated Firebase UID string
    
        Raises:
            IDValidationError: If value is not a valid Firebase UID (or valid test format in test mode)
        """
        # Check if we're in test mode
        test_mode = os.getenv('TEST_MODE', 'false').lower() == 'true'
    
        # Standard Firebase UID validation
        if is_valid_firebase_uid(value):
            logger.debug(f"Validated Firebase UID{' in ' + context if context else ''}: {value}")
            return str(value)
    
        # In test mode, also accept additional formats
        if test_mode and isinstance(value, str):
            # Accept UUID format (for test users)
            if is_valid_uuid(value):
                logger.debug(f"Validated UUID as test user ID{' in ' + context if context else ''}: {value}")
                return str(value)
    
            # Accept test ID patterns like 'test-firebase-uid-123' or 'test-uid-defaults'
            if value.startswith('test-') or value.endswith('-defaults'):
                logger.debug(f"Validated test ID pattern{' in ' + context if context else ''}: {value}")
                return str(value)
    
        # Invalid format - raise error
        expected_format = "Firebase UID" if not test_mode else "Firebase UID, UUID, or test ID pattern (test mode)"
>       raise IDValidationError(
            f"Invalid Firebase UID{' in ' + context if context else ''}. Got: {repr(value)} (type: {type(value).__name__}), expected: {expected_format}",
            value,
            IDType.FIREBASE_UID
        )
E       app.utils.id_validation.IDValidationError: Invalid Firebase UID in test valid UID: abcd1234efgh5678ijkl9012mnop3456. Got: 'abcd1234efgh5678ijkl9012mnop3456' (type: str), expected: Firebase UID, UUID, or test ID pattern (test mode). Got: 'abcd1234efgh5678ijkl9012mnop3456' (type: str), expected: firebase_uid

backend/app/utils/id_validation.py:143: IDValidationError
__________ TestLiveSystemHealth.test_authenticated_endpoint_behavior ___________

self = <test_live_system.TestLiveSystemHealth object at 0x718db30b8f10>

>   ???
E   AssertionError: Should require authentication
E   assert 403 == 401
E    +  where 403 = <Response [403]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_live_system.py:140: AssertionError

During handling of the above exception, another exception occurred:

self = <test_live_system.TestLiveSystemHealth object at 0x718db30b8f10>

>   ???
E   Failed: Authentication test failed: Should require authentication
E   assert 403 == 401
E    +  where 403 = <Response [403]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_live_system.py:155: Failed
----------------------------- Captured stdout call -----------------------------
My-photos without auth: 403
___________________ TestPhotoModel.test_like_count_property ____________________

self = <test_photo_model.TestPhotoModel object at 0x718db30db590>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_model.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1232ab0>
child = <Mock id='124853385006416'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245dd80>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853385005968'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
_______________ TestPhotoModel.test_collaborator_names_property ________________

self = <test_photo_model.TestPhotoModel object at 0x718db30dbc90>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_model.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1223710>
child = <Mock id='124853381575504'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245e900>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853381574160'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
_____ TestPhotoModel.test_photographer_name_property_owner_is_photographer _____

self = <test_photo_model.TestPhotoModel object at 0x718db30da2d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_model.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1223e30>
child = <Mock id='124853378115600'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24d2dc0>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853378114832'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_ TestPhotoModel.test_photographer_name_property_collaborator_is_photographer __

self = <test_photo_model.TestPhotoModel object at 0x718db30ce690>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_model.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1643230>
child = <Mock id='124853382837136'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24d2dc0>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853382825040'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
________________ TestPhotoModel.test_location_display_property _________________

self = <test_photo_model.TestPhotoModel object at 0x718db30ec2d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_model.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1245af0>
child = <Mock id='124853386905360'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24e4e00>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853386904912'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
____________________ TestPhotoModel.test_is_liked_by_method ____________________

self = <test_photo_model.TestPhotoModel object at 0x718db30ecd10>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_model.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1245130>
child = <Mock id='124853377630928'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245dd80>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853377635088'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
__________ TestPhotoDisplayPipeline.test_photo_service_initialization __________

self = <test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db30ff3d0>

>   ???
E   AttributeError: 'PhotoService' object has no attribute 'bucket_name'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:87: AttributeError

During handling of the above exception, another exception occurred:

self = <test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db30ff3d0>

>   ???
E   Failed: PhotoService initialization failed: 'PhotoService' object has no attribute 'bucket_name'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:91: Failed
_____________ TestPhotoDisplayPipeline.test_signed_url_generation ______________

args = (<test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db30ff750>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.photo_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.photo_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestPhotoDisplayPipeline.test_photo_service_recent_photos ___________

self = <test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db2f04710>

>   ???
E   AttributeError: 'coroutine' object has no attribute 'photos'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:195: AttributeError

During handling of the above exception, another exception occurred:

self = <test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db2f04710>

>   ???
E   Failed: PhotoService.get_recent_photos failed: 'coroutine' object has no attribute 'photos'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:206: Failed
----------------------------- Captured stdout call -----------------------------
 PhotoService.get_recent_photos working
____________ TestAuthenticationFlow.test_firebase_token_validation _____________

args = (<test_photo_pipeline.TestAuthenticationFlow object at 0x718db2f057d0>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.auth_middleware.firebase_admin.auth'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.auth_middleware' has no attribute 'firebase_admin'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestAuthenticationFlow.test_auth_middleware_error_handling __________

self = <test_photo_pipeline.TestAuthenticationFlow object at 0x718db2f05e90>

>   ???
E   AssertionError: Should require authentication
E   assert 403 == 401
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:264: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
_________ TestExternalServiceIntegration.test_gcs_bucket_accessibility _________

self = <test_photo_pipeline.TestExternalServiceIntegration object at 0x718db2f067d0>

>   ???
E   AssertionError: Bucket lumen-photos-20250731 should exist
E   assert False
E    +  where False = <bound method Bucket.exists of <Bucket: lumen-photos-20250731>>()
E    +    where <bound method Bucket.exists of <Bucket: lumen-photos-20250731>> = <Bucket: lumen-photos-20250731>.exists

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:292: AssertionError

During handling of the above exception, another exception occurred:

self = <test_photo_pipeline.TestExternalServiceIntegration object at 0x718db2f067d0>

>   ???
E   Failed: GCS bucket accessibility test failed: Bucket lumen-photos-20250731 should exist
E   assert False
E    +  where False = <bound method Bucket.exists of <Bucket: lumen-photos-20250731>>()
E    +    where <bound method Bucket.exists of <Bucket: lumen-photos-20250731>> = <Bucket: lumen-photos-20250731>.exists

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:300: Failed
________________ TestUserDeletion.test_delete_nonexistent_user _________________

self = <test_user_deletion.TestUserDeletion object at 0x718db2f118d0>

>   ???
E   AttributeError: 'UserService' object has no attribute 'delete_user_account'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_deletion.py:140: AttributeError
____________ TestUserDeletion.test_gmail_profile_image_not_deleted _____________

self = <test_user_deletion.TestUserDeletion object at 0x718db2f122d0>
mock_user = <User(handle='test_handle', display_name='Test User')>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_deletion.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.user_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.user_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
___________________ TestUserModel.test_user_type_properties ____________________

self = <test_user_model.TestUserModel object at 0x718db2f1d450>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_model.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db12838f0>
child = <Mock id='124853372168784'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853372168080'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_______________ TestUserModel.test_location_display_with_privacy _______________

self = <test_user_model.TestUserModel object at 0x718db2f1db50>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_model.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1283350>
child = <Mock id='124853386914576'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2466d00>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853386906256'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_______________ TestUserModel.test_model_validation_requirements _______________

self = <test_user_model.TestUserModel object at 0x718db2f1e250>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_model.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1282930>
child = <Mock id='124853373668752'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853373672976'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
___________ TestUserModel.test_photographer_validation_requirements ____________

self = <test_user_model.TestUserModel object at 0x718db2f1e950>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_model.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1283d70>
child = <Mock id='124853391404048'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853391395024'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_______________ TestUserPydanticModels.test_user_profile_models ________________

self = <test_user_model.TestUserPydanticModels object at 0x718db2f1dc90>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_model.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = UserProfilePrivate(id='test-user-id', handle='testuser', display_name='Test User', bio=None, profile_image_url=None, c...r_travel=False, location_preferences=[], website=None, email='test@example.com', privacy_settings={'show_city': False})
item = 'firebase_uid'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra is not None:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'UserProfilePrivate' object has no attribute 'firebase_uid'

backend/venv/lib/python3.11/site-packages/pydantic/main.py:761: AttributeError
___ TestEnhancedUserService.test_update_user_profile_with_artistic_statement ___

self = <test_user_service_enhanced.TestEnhancedUserService object at 0x718db2f278d0>
mock_session_local = <MagicMock name='SessionLocal' id='124853387555856'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_service_enhanced.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db3376490>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <app.services.user_service.UserService object at 0x718db1d05cd0> does not have the attribute 'get_user_profile'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestEnhancedUserService.test_update_user_profile_photographer_specific_fields _

self = <test_user_service_enhanced.TestEnhancedUserService object at 0x718db2f27f50>
mock_session_local = <MagicMock name='SessionLocal' id='124853375489744'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_service_enhanced.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db1185f10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <app.services.user_service.UserService object at 0x718db1186610> does not have the attribute 'get_user_profile'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
____ TestEnhancedUserService.test_update_user_profile_model_specific_fields ____

self = <test_user_service_enhanced.TestEnhancedUserService object at 0x718db2f3c610>
mock_session_local = <MagicMock name='SessionLocal' id='124853381521424'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_service_enhanced.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db1107350>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <app.services.user_service.UserService object at 0x718db1746c10> does not have the attribute 'get_user_profile'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestEnhancedUserService.test_update_user_profile_availability_data ______

self = <test_user_service_enhanced.TestEnhancedUserService object at 0x718db2f3ccd0>
mock_session_local = <MagicMock name='SessionLocal' id='124853378654864'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_service_enhanced.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db12b67d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <app.services.user_service.UserService object at 0x718db148a750> does not have the attribute 'get_user_profile'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestEnhancedUserService.test_upload_profile_image_success ___________

self = <test_user_service_enhanced.TestEnhancedUserService object at 0x718db2f3d350>
mock_storage_client = <MagicMock name='Client' id='124853378454288'>

>   ???
E   AttributeError: 'UserService' object has no attribute 'upload_profile_image'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_service_enhanced.py:213: AttributeError
__________ TestEnhancedUserService.test_upload_profile_image_failure ___________

self = <test_user_service_enhanced.TestEnhancedUserService object at 0x718db2f27550>
mock_storage_client = <MagicMock name='Client' id='124853377085264'>

>   ???
E   AttributeError: 'UserService' object has no attribute 'upload_profile_image'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_service_enhanced.py:236: AttributeError
____________ TestEnhancedUserService.test_update_profile_image_url _____________

self = <test_user_service_enhanced.TestEnhancedUserService object at 0x718db2f3d310>
mock_session_local = <MagicMock name='SessionLocal' id='124853377073808'>

>   ???
E   AttributeError: 'UserService' object has no attribute 'update_profile_image'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_service_enhanced.py:251: AttributeError
______________ TestEnhancedUserService.test_remove_profile_image _______________

self = <test_user_service_enhanced.TestEnhancedUserService object at 0x718db2f3db50>
mock_session_local = <MagicMock name='SessionLocal' id='124853373434832'>

>   ???
E   AttributeError: 'UserService' object has no attribute 'remove_profile_image'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_service_enhanced.py:275: AttributeError
_________________ TestEnhancedUserService.test_get_user_stats __________________

self = <test_user_service_enhanced.TestEnhancedUserService object at 0x718db2f3e210>
mock_session_local = <MagicMock name='SessionLocal' id='124853378723600'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_user_service_enhanced.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.user_service.UserService object at 0x718db0f8cc50>
user_id = 'firebase-uid-123'

    async def get_user_stats(self, user_id: str):
        """Get user's statistics (photo count, likes, etc.)"""
        from ..models.photo import Photo
        from sqlalchemy import func
    
        db = SessionLocal()
        try:
            # Count photos
            photo_count = db.query(Photo).filter(Photo.user_id == user_id).count()
    
            # Count total likes across all user's photos
            # Since like_count is a property that counts interactions, we need to count them directly
            total_likes = 0
            photos = db.query(Photo).filter(Photo.user_id == user_id).all()
>           for photo in photos:
E           TypeError: 'Mock' object is not iterable

backend/app/services/user_service.py:404: TypeError
----------------------------- Captured stderr call -----------------------------
ERROR:app.services.user_service:Failed to get stats for user firebase-uid-123: 'Mock' object is not iterable
------------------------------ Captured log call -------------------------------
ERROR    app.services.user_service:user_service.py:422 Failed to get stats for user firebase-uid-123: 'Mock' object is not iterable
__________ TestLiveSystemHealth.test_authenticated_endpoint_behavior ___________

self = <diagnostics.test_live_system.TestLiveSystemHealth object at 0x718db2f4a810>

>   ???
E   AssertionError: Should require authentication
E   assert 403 == 401
E    +  where 403 = <Response [403]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_live_system.py:140: AssertionError

During handling of the above exception, another exception occurred:

self = <diagnostics.test_live_system.TestLiveSystemHealth object at 0x718db2f4a810>

>   ???
E   Failed: Authentication test failed: Should require authentication
E   assert 403 == 401
E    +  where 403 = <Response [403]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_live_system.py:155: Failed
----------------------------- Captured stdout call -----------------------------
My-photos without auth: 403
__________ TestPhotoDisplayPipeline.test_photo_service_initialization __________

self = <diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db2f532d0>

>   ???
E   AttributeError: 'PhotoService' object has no attribute 'bucket_name'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:87: AttributeError

During handling of the above exception, another exception occurred:

self = <diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db2f532d0>

>   ???
E   Failed: PhotoService initialization failed: 'PhotoService' object has no attribute 'bucket_name'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:91: Failed
_____________ TestPhotoDisplayPipeline.test_signed_url_generation ______________

args = (<diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db2f53950>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.photo_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.photo_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestPhotoDisplayPipeline.test_photo_service_recent_photos ___________

self = <diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db2f5cdd0>

>   ???
E   AttributeError: 'coroutine' object has no attribute 'photos'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:195: AttributeError

During handling of the above exception, another exception occurred:

self = <diagnostics.test_photo_pipeline.TestPhotoDisplayPipeline object at 0x718db2f5cdd0>

>   ???
E   Failed: PhotoService.get_recent_photos failed: 'coroutine' object has no attribute 'photos'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:206: Failed
----------------------------- Captured stdout call -----------------------------
 PhotoService.get_recent_photos working
____________ TestAuthenticationFlow.test_firebase_token_validation _____________

args = (<diagnostics.test_photo_pipeline.TestAuthenticationFlow object at 0x718db2f5de50>,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.auth_middleware.firebase_admin.auth'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.auth_middleware' has no attribute 'firebase_admin'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
__________ TestAuthenticationFlow.test_auth_middleware_error_handling __________

self = <diagnostics.test_photo_pipeline.TestAuthenticationFlow object at 0x718db2f5e510>

>   ???
E   AssertionError: Should require authentication
E   assert 403 == 401
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:264: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
_________ TestExternalServiceIntegration.test_gcs_bucket_accessibility _________

self = <diagnostics.test_photo_pipeline.TestExternalServiceIntegration object at 0x718db2f52f10>

>   ???
E   AssertionError: Bucket lumen-photos-20250731 should exist
E   assert False
E    +  where False = <bound method Bucket.exists of <Bucket: lumen-photos-20250731>>()
E    +    where <bound method Bucket.exists of <Bucket: lumen-photos-20250731>> = <Bucket: lumen-photos-20250731>.exists

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:292: AssertionError

During handling of the above exception, another exception occurred:

self = <diagnostics.test_photo_pipeline.TestExternalServiceIntegration object at 0x718db2f52f10>

>   ???
E   Failed: GCS bucket accessibility test failed: Bucket lumen-photos-20250731 should exist
E   assert False
E    +  where False = <bound method Bucket.exists of <Bucket: lumen-photos-20250731>>()
E    +    where <bound method Bucket.exists of <Bucket: lumen-photos-20250731>> = <Bucket: lumen-photos-20250731>.exists

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:300: Failed
_________ TestIDValidationIntegration.test_valid_firebase_uid_formats __________

self = <integration.test_id_validation_integration.TestIDValidationIntegration object at 0x718db2f86750>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_id_validation_integration.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = 'abcd1234efgh5678ijkl9012mnop3456'
context = 'test valid UID: abcd1234efgh5678ijkl9012mnop3456'

    def validate_firebase_uid(value: any, context: str = "") -> FirebaseUID:
        """
        Validate and return a Firebase UID, raising exception if invalid
    
        In TEST_MODE, also accepts UUID format and test ID patterns for test users
    
        Args:
            value: Value to validate as Firebase UID
            context: Additional context for error messages
    
        Returns:
            Validated Firebase UID string
    
        Raises:
            IDValidationError: If value is not a valid Firebase UID (or valid test format in test mode)
        """
        # Check if we're in test mode
        test_mode = os.getenv('TEST_MODE', 'false').lower() == 'true'
    
        # Standard Firebase UID validation
        if is_valid_firebase_uid(value):
            logger.debug(f"Validated Firebase UID{' in ' + context if context else ''}: {value}")
            return str(value)
    
        # In test mode, also accept additional formats
        if test_mode and isinstance(value, str):
            # Accept UUID format (for test users)
            if is_valid_uuid(value):
                logger.debug(f"Validated UUID as test user ID{' in ' + context if context else ''}: {value}")
                return str(value)
    
            # Accept test ID patterns like 'test-firebase-uid-123' or 'test-uid-defaults'
            if value.startswith('test-') or value.endswith('-defaults'):
                logger.debug(f"Validated test ID pattern{' in ' + context if context else ''}: {value}")
                return str(value)
    
        # Invalid format - raise error
        expected_format = "Firebase UID" if not test_mode else "Firebase UID, UUID, or test ID pattern (test mode)"
>       raise IDValidationError(
            f"Invalid Firebase UID{' in ' + context if context else ''}. Got: {repr(value)} (type: {type(value).__name__}), expected: {expected_format}",
            value,
            IDType.FIREBASE_UID
        )
E       app.utils.id_validation.IDValidationError: Invalid Firebase UID in test valid UID: abcd1234efgh5678ijkl9012mnop3456. Got: 'abcd1234efgh5678ijkl9012mnop3456' (type: str), expected: Firebase UID, UUID, or test ID pattern (test mode). Got: 'abcd1234efgh5678ijkl9012mnop3456' (type: str), expected: firebase_uid

backend/app/utils/id_validation.py:143: IDValidationError
________________ TestUserDeletion.test_delete_nonexistent_user _________________

self = <integration.test_user_deletion.TestUserDeletion object at 0x718db2fd0f10>

>   ???
E   AttributeError: 'UserService' object has no attribute 'delete_user_account'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_user_deletion.py:140: AttributeError
____________ TestUserDeletion.test_gmail_profile_image_not_deleted _____________

self = <integration.test_user_deletion.TestUserDeletion object at 0x718db2fd1190>
mock_user = <User(handle='test_handle', display_name='Test User')>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_user_deletion.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.user_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.user_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
_ TestAuthMiddlewareIntegration.test_middleware_with_fastapi_dependency_injection _

self = <unit.test_auth_middleware.TestAuthMiddlewareIntegration object at 0x718db2fe4890>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_auth_middleware.py:263: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/protected "HTTP/1.1 403 Forbidden"
INFO:httpx:HTTP Request: GET http://testserver/optional "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/protected "HTTP/1.1 403 Forbidden"
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/optional "HTTP/1.1 403 Forbidden"
___________________ TestPhotoModel.test_like_count_property ____________________

self = <unit.test_photo_model.TestPhotoModel object at 0x718db2e03150>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_photo_model.py:99: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db18119d0>
child = <Mock id='124853357586768'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245dd80>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853357589904'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
_______________ TestPhotoModel.test_collaborator_names_property ________________

self = <unit.test_photo_model.TestPhotoModel object at 0x718db2e03850>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_photo_model.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db18c85f0>
child = <Mock id='124853519797776'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245e900>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853519807504'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
_____ TestPhotoModel.test_photographer_name_property_owner_is_photographer _____

self = <unit.test_photo_model.TestPhotoModel object at 0x718db2e03f50>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_photo_model.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db18cb4d0>
child = <Mock id='124853376360272'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24d2dc0>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853376356304'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_ TestPhotoModel.test_photographer_name_property_collaborator_is_photographer __

self = <unit.test_photo_model.TestPhotoModel object at 0x718db2e01a10>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_photo_model.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1f7eb70>
child = <Mock id='124853390773648'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24d2dc0>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853390770384'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
________________ TestPhotoModel.test_location_display_property _________________

self = <unit.test_photo_model.TestPhotoModel object at 0x718db2ff2350>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_photo_model.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1f7fe90>
child = <Mock id='124853376205776'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24e4e00>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853376217616'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
____________________ TestPhotoModel.test_is_liked_by_method ____________________

self = <unit.test_photo_model.TestPhotoModel object at 0x718db2e109d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_photo_model.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db187e9f0>
child = <Mock id='124853520252624'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245dd80>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853520250128'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
___________________ TestUserModel.test_user_type_properties ____________________

self = <unit.test_user_model.TestUserModel object at 0x718db2e1a390>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_model.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Test Photographer', 'email': 'photo@example.com', 'firebase_uid': 'test-photographer', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
_______________ TestUserModel.test_location_display_with_privacy _______________

self = <unit.test_user_model.TestUserModel object at 0x718db2e1a710>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_model.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Location User', 'email': 'location@example.com', 'firebase_uid': 'test-location', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
_______________ TestUserModel.test_model_validation_requirements _______________

self = <unit.test_user_model.TestUserModel object at 0x718db2e1aa90>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_model.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Test Model', 'email': 'model@example.com', 'firebase_uid': 'test-model', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
___________ TestUserModel.test_photographer_validation_requirements ____________

self = <unit.test_user_model.TestUserModel object at 0x718db2e1b190>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_model.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Photo User', 'email': 'photovalidation@example.com', 'firebase_uid': 'test-photographer-validation', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
_______________ TestUserPydanticModels.test_user_profile_models ________________

self = <unit.test_user_model.TestUserPydanticModels object at 0x718db2e28f90>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_model.py:316: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = UserProfilePrivate(id='test-user-id', handle='testuser', display_name='Test User', bio=None, profile_image_url=None, c...r_travel=False, location_preferences=[], website=None, email='test@example.com', privacy_settings={'show_city': False})
item = 'firebase_uid'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra is not None:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'UserProfilePrivate' object has no attribute 'firebase_uid'

backend/venv/lib/python3.11/site-packages/pydantic/main.py:761: AttributeError
___ TestEnhancedUserService.test_update_user_profile_with_artistic_statement ___

self = <unit.test_user_service_enhanced.TestEnhancedUserService object at 0x718db2e2cc10>
mock_session_local = <MagicMock name='SessionLocal' id='124853358037584'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_service_enhanced.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db2028090>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <app.services.user_service.UserService object at 0x718db00e1f50> does not have the attribute 'get_user_profile'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
_ TestEnhancedUserService.test_update_user_profile_photographer_specific_fields _

self = <unit.test_user_service_enhanced.TestEnhancedUserService object at 0x718db2e2cf90>
mock_session_local = <MagicMock name='SessionLocal' id='124853381930640'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_service_enhanced.py:113: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db17a8e10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <app.services.user_service.UserService object at 0x718db17a8d50> does not have the attribute 'get_user_profile'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
____ TestEnhancedUserService.test_update_user_profile_model_specific_fields ____

self = <unit.test_user_service_enhanced.TestEnhancedUserService object at 0x718db2e2d310>
mock_session_local = <MagicMock name='SessionLocal' id='124853382788688'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_service_enhanced.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db1878390>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <app.services.user_service.UserService object at 0x718db187ba10> does not have the attribute 'get_user_profile'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
______ TestEnhancedUserService.test_update_user_profile_availability_data ______

self = <unit.test_user_service_enhanced.TestEnhancedUserService object at 0x718db2e2d7d0>
mock_session_local = <MagicMock name='SessionLocal' id='124853403283152'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_service_enhanced.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/unittest/mock.py:1446: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <unittest.mock._patch object at 0x718db2c05390>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <app.services.user_service.UserService object at 0x718db2c06810> does not have the attribute 'get_user_profile'

/usr/lib/python3.11/unittest/mock.py:1419: AttributeError
__________ TestEnhancedUserService.test_upload_profile_image_success ___________

self = <unit.test_user_service_enhanced.TestEnhancedUserService object at 0x718db2e2de50>
mock_storage_client = <MagicMock name='Client' id='124853382636112'>

>   ???
E   AttributeError: 'UserService' object has no attribute 'upload_profile_image'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_service_enhanced.py:213: AttributeError
__________ TestEnhancedUserService.test_upload_profile_image_failure ___________

self = <unit.test_user_service_enhanced.TestEnhancedUserService object at 0x718db2e2e4d0>
mock_storage_client = <MagicMock name='Client' id='124853374490320'>

>   ???
E   AttributeError: 'UserService' object has no attribute 'upload_profile_image'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_service_enhanced.py:236: AttributeError
____________ TestEnhancedUserService.test_update_profile_image_url _____________

self = <unit.test_user_service_enhanced.TestEnhancedUserService object at 0x718db2e2eb50>
mock_session_local = <MagicMock name='SessionLocal' id='124853374620624'>

>   ???
E   AttributeError: 'UserService' object has no attribute 'update_profile_image'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_service_enhanced.py:251: AttributeError
______________ TestEnhancedUserService.test_remove_profile_image _______________

self = <unit.test_user_service_enhanced.TestEnhancedUserService object at 0x718db2e2f1d0>
mock_session_local = <MagicMock name='SessionLocal' id='124853357992656'>

>   ???
E   AttributeError: 'UserService' object has no attribute 'remove_profile_image'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_service_enhanced.py:275: AttributeError
_________________ TestEnhancedUserService.test_get_user_stats __________________

self = <unit.test_user_service_enhanced.TestEnhancedUserService object at 0x718db2e2fe90>
mock_session_local = <MagicMock name='SessionLocal' id='124853391611152'>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/unit/test_user_service_enhanced.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <app.services.user_service.UserService object at 0x718db1d06fd0>
user_id = 'firebase-uid-123'

    async def get_user_stats(self, user_id: str):
        """Get user's statistics (photo count, likes, etc.)"""
        from ..models.photo import Photo
        from sqlalchemy import func
    
        db = SessionLocal()
        try:
            # Count photos
            photo_count = db.query(Photo).filter(Photo.user_id == user_id).count()
    
            # Count total likes across all user's photos
            # Since like_count is a property that counts interactions, we need to count them directly
            total_likes = 0
            photos = db.query(Photo).filter(Photo.user_id == user_id).all()
>           for photo in photos:
E           TypeError: 'Mock' object is not iterable

backend/app/services/user_service.py:404: TypeError
----------------------------- Captured stderr call -----------------------------
ERROR:app.services.user_service:Failed to get stats for user firebase-uid-123: 'Mock' object is not iterable
------------------------------ Captured log call -------------------------------
ERROR    app.services.user_service:user_service.py:422 Failed to get stats for user firebase-uid-123: 'Mock' object is not iterable
______________ TestAuthEndpoints.test_auth_status_unauthenticated ______________

self = <tests.integration.test_auth_endpoints.TestAuthEndpoints object at 0x718db2e3a3d0>
client = <starlette.testclient.TestClient object at 0x718db00d63d0>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_auth_endpoints.py:23: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/auth/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/auth/status "HTTP/1.1 403 Forbidden"
_______________ TestAuthEndpoints.test_auth_status_authenticated _______________

self = <tests.integration.test_auth_endpoints.TestAuthEndpoints object at 0x718db2e2e150>
mock_get_user = <AsyncMock name='get_optional_user' id='124853374631824'>
client = <starlette.testclient.TestClient object at 0x718db10b2f90>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_auth_endpoints.py:44: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/auth/status "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/auth/status "HTTP/1.1 403 Forbidden"
______________ TestAuthEndpoints.test_get_profile_unauthenticated ______________

self = <tests.integration.test_auth_endpoints.TestAuthEndpoints object at 0x718db2e3a650>
client = <starlette.testclient.TestClient object at 0x718db1d4ca90>

>   ???
E   assert 403 == 401
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_auth_endpoints.py:57: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/auth/profile "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/auth/profile "HTTP/1.1 403 Forbidden"
_______________ TestAuthEndpoints.test_get_profile_authenticated _______________

self = <tests.integration.test_auth_endpoints.TestAuthEndpoints object at 0x718db2e3aa10>
mock_get_user = <AsyncMock name='get_current_user' id='124853404292688'>
client = <starlette.testclient.TestClient object at 0x718db2cff1d0>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_auth_endpoints.py:74: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/auth/profile "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/auth/profile "HTTP/1.1 403 Forbidden"
________________ TestAuthEndpoints.test_demo_protected_endpoint ________________

self = <tests.integration.test_auth_endpoints.TestAuthEndpoints object at 0x718db2e3b510>
mock_get_user = <AsyncMock name='get_current_user' id='124853404290640'>
client = <starlette.testclient.TestClient object at 0x718db2cfe090>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_auth_endpoints.py:112: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/auth/demo-protected "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/auth/demo-protected "HTTP/1.1 403 Forbidden"
________ TestAuthEndpoints.test_demo_protected_endpoint_unauthenticated ________

self = <tests.integration.test_auth_endpoints.TestAuthEndpoints object at 0x718db2e3bbd0>
client = <starlette.testclient.TestClient object at 0x718db1c13310>

>   ???
E   assert 403 == 401
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_auth_endpoints.py:124: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/auth/demo-protected "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/auth/demo-protected "HTTP/1.1 403 Forbidden"
____________ TestDatabaseConnection.test_database_session_creation _____________

self = <tests.integration.test_database_integration.TestDatabaseConnection object at 0x718db2e56ed0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db187aad0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2308: in execute
    return self._execute_internal(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2088: in _execute_internal
    statement = coercions.expect(roles.StatementRole, statement)
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/coercions.py:413: in expect
    resolved = impl._literal_coercion(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/coercions.py:638: in _literal_coercion
    return self._text_coercion(element, argname, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/coercions.py:631: in _text_coercion
    return _no_text_coercion(element, argname)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

element = 'SELECT 1', argname = None
exc_cls = <class 'sqlalchemy.exc.ArgumentError'>, extra = None, err = None

    def _no_text_coercion(
        element: Any,
        argname: Optional[str] = None,
        exc_cls: Type[exc.SQLAlchemyError] = exc.ArgumentError,
        extra: Optional[str] = None,
        err: Optional[Exception] = None,
    ) -> NoReturn:
>       raise exc_cls(
            "%(extra)sTextual SQL expression %(expr)r %(argname)sshould be "
            "explicitly declared as text(%(expr)r)"
            % {
                "expr": util.ellipses_string(element),
                "argname": "for argument %s" % (argname,) if argname else "",
                "extra": "%s " % extra if extra else "",
            }
        ) from err
E       sqlalchemy.exc.ArgumentError: Textual SQL expression 'SELECT 1' should be explicitly declared as text('SELECT 1')

backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/coercions.py:601: ArgumentError
__________ TestDatabaseConnection.test_database_transaction_rollback ___________

self = <tests.integration.test_database_integration.TestDatabaseConnection object at 0x718db2e575d0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db20d4310>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Rollback Test', 'email': 'rollback@example.com', 'firebase_uid': 'test-rollback-uid', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
________ TestUserDatabaseOperations.test_create_user_with_relationships ________

self = <sqlalchemy.engine.base.Connection object at 0x718db14faf90>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db14fa090>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db14fbd10>
parameters = [{'country': 'USA', 'id': 1, 'is_capital': False, 'latitude': 40.7128, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db16f0a90; closed: -1>
statement = 'INSERT INTO cities (id, name, country, region, latitude, longitude, population, is_capital, tier) VALUES (%(id)s, %(n...ntry)s, %(region)s, %(latitude)s, %(longitude)s, %(population)s, %(is_capital)s, %(tier)s) RETURNING cities.created_at'
parameters = {'country': 'USA', 'id': 1, 'is_capital': False, 'latitude': 40.7128, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db14fa090>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "cities_pkey"
E       DETAIL:  Key (id)=(1) already exists.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: UniqueViolation

The above exception was the direct cause of the following exception:

self = <tests.integration.test_database_integration.TestUserDatabaseOperations object at 0x718db2e57ed0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db14fa3d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db16f0a90; closed: -1>
statement = 'INSERT INTO cities (id, name, country, region, latitude, longitude, population, is_capital, tier) VALUES (%(id)s, %(n...ntry)s, %(region)s, %(latitude)s, %(longitude)s, %(population)s, %(is_capital)s, %(tier)s) RETURNING cities.created_at'
parameters = {'country': 'USA', 'id': 1, 'is_capital': False, 'latitude': 40.7128, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db14fa090>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (psycopg2.errors.UniqueViolation) duplicate key value violates unique constraint "cities_pkey"
E       DETAIL:  Key (id)=(1) already exists.
E       
E       [SQL: INSERT INTO cities (id, name, country, region, latitude, longitude, population, is_capital, tier) VALUES (%(id)s, %(name)s, %(country)s, %(region)s, %(latitude)s, %(longitude)s, %(population)s, %(is_capital)s, %(tier)s) RETURNING cities.created_at]
E       [parameters: {'id': 1, 'name': 'New York', 'country': 'USA', 'region': None, 'latitude': 40.7128, 'longitude': -74.006, 'population': None, 'is_capital': False, 'tier': 1}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: IntegrityError
___________ TestUserDatabaseOperations.test_user_unique_constraints ____________

self = <tests.integration.test_database_integration.TestUserDatabaseOperations object at 0x718db2e5c610>
db_session = <sqlalchemy.orm.session.Session object at 0x718db1d53990>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:115: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Unique User 1', 'email': 'unique1@example.com', 'firebase_uid': 'unique-test-uid-1', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
_____________ TestUserDatabaseOperations.test_user_cascade_delete ______________

self = <tests.integration.test_database_integration.TestUserDatabaseOperations object at 0x718db2e5cd10>
db_session = <sqlalchemy.orm.session.Session object at 0x718db113d0d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Cascade Test', 'email': 'cascade@example.com', 'firebase_uid': 'cascade-test-uid', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
_________ TestPhotoDatabaseOperations.test_create_photo_with_metadata __________

self = <tests.integration.test_database_integration.TestPhotoDatabaseOperations object at 0x718db2e38210>
db_session = <sqlalchemy.orm.session.Session object at 0x718db9b101d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Photo User', 'email': 'photo@example.com', 'firebase_uid': 'photo-test-uid', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
______ TestPhotoDatabaseOperations.test_photo_collaborator_relationships _______

self = <tests.integration.test_database_integration.TestPhotoDatabaseOperations object at 0x718db2e5c590>
db_session = <sqlalchemy.orm.session.Session object at 0x718db1e14110>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'John Photographer', 'email': 'photographer@example.com', 'firebase_uid': 'photographer-uid', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
_________ TestPhotoDatabaseOperations.test_photo_interaction_tracking __________

self = <tests.integration.test_database_integration.TestPhotoDatabaseOperations object at 0x718db2e5d090>
db_session = <sqlalchemy.orm.session.Session object at 0x718db1766710>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:304: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Photo Owner', 'email': 'owner@example.com', 'firebase_uid': 'owner-uid', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
___________ TestDatabasePerformance.test_user_photo_query_efficiency ___________

self = <tests.integration.test_database_integration.TestDatabasePerformance object at 0x718db2e5d5d0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db2c3bfd0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:365: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
<string>:4: in __init__
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:566: in _initialize_instance
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state.py:564: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <User(handle='None', display_name='None')>
kwargs = {'city_id': 1, 'display_name': 'Performance User', 'email': 'performance@example.com', 'firebase_uid': 'performance-test-uid', ...}
cls_ = <class 'app.models.user.User'>, k = 'firebase_uid'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
                raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
>           setattr(self, k, kwargs[k])
E           AttributeError: property 'firebase_uid' of 'User' object has no setter

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/decl_base.py:2145: AttributeError
____________ TestDatabasePerformance.test_photo_search_with_indexes ____________

self = <sqlalchemy.engine.base.Connection object at 0x718db20ee250>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db20ec450>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[
                Any
            ] = self.dialect.dispatch.do_execute
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {
                            imv_batch.batchnum}/{imv_batch.total_batches} ({
                            'ordered'
                            if imv_batch.rows_sorted else 'unordered'
                        }{
                            '; batch not supported'
                            if imv_batch.is_downgraded
                            else ''
                        })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db2257010; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con...3)s, %(is_portfolio__3)s, %(status__3)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at, photos.id'
parameters = {'category__0': 'portrait', 'category__1': 'portrait', 'category__2': 'portrait', 'category__3': 'portrait', ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db20ec450>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DatatypeMismatch: column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ...dscape','nature']::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: DatatypeMismatch

The above exception was the direct cause of the following exception:

self = <tests.integration.test_database_integration.TestDatabasePerformance object at 0x718db2e5d9d0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db20145d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_database_integration.py:423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1136: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1843: in _execute_context
    return self._exec_insertmany_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2120: in _exec_insertmany_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2112: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db2257010; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con...3)s, %(is_portfolio__3)s, %(status__3)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at, photos.id'
parameters = {'category__0': 'portrait', 'category__1': 'portrait', 'category__2': 'portrait', 'category__3': 'portrait', ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db20ec450>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DatatypeMismatch) column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ...dscape','nature']::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.
E       
E       [SQL: INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, content_rating, category, series_id, is_deleted, is_public, view_count, is_collaborative, model_release_status, extra_metadata, is_portf ... 1621 characters truncated ... o__3)s, %(status__3)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at, photos.id]
E       [parameters: {'thumbnail_url__0': None, 'city_id__0': None, 'series_id__0': None, 'location_name__0': None, 'is_collaborative__0': False, 'description__0': None, 'is_portfolio__0': False, 'user_id__0': UUID('560a2e2b-5462-46ca-90ed-d20c714c29f4'), 'image_url__0': None, 'model_release_status__0': 'none', 'user_tags__0': ['landscape', 'nature'], 'category__0': 'portrait', 'title__0': 'Landscape Photo', 'id__0': UUID('88a05a6b-6541-4693-960c-851d02058a1a'), 'is_deleted__0': False, 'view_count__0': 0, 'content_rating__0': 'general', 'status__0': 'active', 'is_public__0': True, 'extra_metadata__0': '{}', 'thumbnail_url__1': None, 'city_id__1': None, 'series_id__1': None, 'location_name__1': None, 'is_collaborative__1': False, 'description__1': None, 'is_portfolio__1': False, 'user_id__1': UUID('560a2e2b-5462-46ca-90ed-d20c714c29f4'), 'image_url__1': None, 'model_release_status__1': 'none', 'user_tags__1': ['portrait', 'people'], 'category__1': 'portrait', 'title__1': 'Portrait Photo', 'id__1': UUID('d30e8b18-90bb-4e2b-b54a-b95453d1af91'), 'is_deleted__1': False, 'view_count__1': 0, 'content_rating__1': 'general', 'status__1': 'active', 'is_public__1': True, 'extra_metadata__1': '{}', 'thumbnail_url__2': None, 'city_id__2': None, 'series_id__2': None, 'location_name__2': None, 'is_collaborative__2': False, 'description__2': None, 'is_portfolio__2': False, 'user_id__2': UUID('560a2e2b-5462-46ca-90ed-d20c714c29f4'), 'image_url__2': None, 'model_release_status__2': 'none', 'user_tags__2': ['personal'], 'category__2': 'portrait', 'title__2': 'Private Photo', 'id__2': UUID('39769273-361f-4ace-ad26-328a708e6588'), 'is_deleted__2': False, 'view_count__2': 0, 'content_rating__2': 'general', 'status__2': 'active', 'is_public__2': False, 'extra_metadata__2': '{}', 'thumbnail_url__3': None, 'city_id__3': None, 'series_id__3': None, 'location_name__3': None, 'is_collaborative__3': False, 'description__3': None, 'is_portfolio__3': False, 'user_id__3': UUID('560a2e2b-5462-46ca-90ed-d20c714c29f4'), 'image_url__3': None, 'model_release_status__3': 'none', 'user_tags__3': ['studio', 'portrait'], 'category__3': 'portrait', 'title__3': 'Studio Photo', 'id__3': UUID('4f9f5895-e7db-42d8-8f16-44f7b9b0c1fd'), 'is_deleted__3': False, 'view_count__3': 0, 'content_rating__3': 'general', 'status__3': 'active', 'is_public__3': True, 'extra_metadata__3': '{}'}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: ProgrammingError
_________ TestIDValidationIntegration.test_valid_firebase_uid_formats __________

self = <tests.integration.test_id_validation_integration.TestIDValidationIntegration object at 0x718db2e716d0>

>   ???

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_id_validation_integration.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = 'abcd1234efgh5678ijkl9012mnop3456'
context = 'test valid UID: abcd1234efgh5678ijkl9012mnop3456'

    def validate_firebase_uid(value: any, context: str = "") -> FirebaseUID:
        """
        Validate and return a Firebase UID, raising exception if invalid
    
        In TEST_MODE, also accepts UUID format and test ID patterns for test users
    
        Args:
            value: Value to validate as Firebase UID
            context: Additional context for error messages
    
        Returns:
            Validated Firebase UID string
    
        Raises:
            IDValidationError: If value is not a valid Firebase UID (or valid test format in test mode)
        """
        # Check if we're in test mode
        test_mode = os.getenv('TEST_MODE', 'false').lower() == 'true'
    
        # Standard Firebase UID validation
        if is_valid_firebase_uid(value):
            logger.debug(f"Validated Firebase UID{' in ' + context if context else ''}: {value}")
            return str(value)
    
        # In test mode, also accept additional formats
        if test_mode and isinstance(value, str):
            # Accept UUID format (for test users)
            if is_valid_uuid(value):
                logger.debug(f"Validated UUID as test user ID{' in ' + context if context else ''}: {value}")
                return str(value)
    
            # Accept test ID patterns like 'test-firebase-uid-123' or 'test-uid-defaults'
            if value.startswith('test-') or value.endswith('-defaults'):
                logger.debug(f"Validated test ID pattern{' in ' + context if context else ''}: {value}")
                return str(value)
    
        # Invalid format - raise error
        expected_format = "Firebase UID" if not test_mode else "Firebase UID, UUID, or test ID pattern (test mode)"
>       raise IDValidationError(
            f"Invalid Firebase UID{' in ' + context if context else ''}. Got: {repr(value)} (type: {type(value).__name__}), expected: {expected_format}",
            value,
            IDType.FIREBASE_UID
        )
E       app.utils.id_validation.IDValidationError: Invalid Firebase UID in test valid UID: abcd1234efgh5678ijkl9012mnop3456. Got: 'abcd1234efgh5678ijkl9012mnop3456' (type: str), expected: Firebase UID, UUID, or test ID pattern (test mode). Got: 'abcd1234efgh5678ijkl9012mnop3456' (type: str), expected: firebase_uid

backend/app/utils/id_validation.py:143: IDValidationError
____ TestPhotoServiceIDValidation.test_photo_service_with_invalid_photo_id _____

args = (<tests.integration.test_id_validation_integration.TestPhotoServiceIDValidation object at 0x718db2e398d0>,)
keywargs = {'db_session': <sqlalchemy.orm.session.Session object at 0x718db145a410>, 'mock_firebase_user': <Mock spec='AuthUser' id='124853384900112'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.photo_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.photo_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
_____ TestPhotoServiceIDValidation.test_ensure_user_exists_with_valid_uid ______

args = (<tests.integration.test_id_validation_integration.TestPhotoServiceIDValidation object at 0x718db2fb2c10>,)
keywargs = {'db_session': <sqlalchemy.orm.session.Session object at 0x718db12d0710>, 'mock_firebase_user': <Mock spec='AuthUser' id='124853376849296'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.photo_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.photo_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
____ TestPhotoServiceIDValidation.test_ensure_user_exists_with_invalid_uid _____

args = (<tests.integration.test_id_validation_integration.TestPhotoServiceIDValidation object at 0x718db2e70f90>,)
keywargs = {'db_session': <sqlalchemy.orm.session.Session object at 0x718db1dcaf90>, 'mock_invalid_firebase_user': <Mock spec='AuthUser' id='124853388349136'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.photo_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.photo_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
____________ TestEndToEndPhotoFlow.test_complete_photo_upload_flow _____________

args = (<tests.integration.test_id_validation_integration.TestEndToEndPhotoFlow object at 0x718db2e7cc10>,)
keywargs = {'client': <starlette.testclient.TestClient object at 0x718db1845a90>, 'db_session': <sqlalchemy.orm.session.Session object at 0x718db1847890>, 'mock_complete_firebase_user': <Mock spec='AuthUser' id='124853382566224'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.photo_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.photo_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
________ TestEndToEndPhotoFlow.test_photo_retrieval_with_id_validation _________

args = (<tests.integration.test_id_validation_integration.TestEndToEndPhotoFlow object at 0x718db2e7d290>,)
keywargs = {'db_session': <sqlalchemy.orm.session.Session object at 0x718db9abe050>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'app.services.photo_service.storage'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'app.services.photo_service' has no attribute 'storage'

/usr/lib/python3.11/pkgutil.py:715: AttributeError
________ TestEndToEndPhotoFlow.test_invalid_id_formats_rejected_in_flow ________

self = <tests.integration.test_id_validation_integration.TestEndToEndPhotoFlow object at 0x718db2e7d990>
db_session = <sqlalchemy.orm.session.Session object at 0x718db9b98b90>

>   ???
E   AttributeError: 'PhotoService' object has no attribute 'get_photo_by_id'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_id_validation_integration.py:438: AttributeError
_______________ TestPhotoEndpoints.test_get_recent_photos_empty ________________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e7f0d0>
client = <starlette.testclient.TestClient object at 0x718db9b98fd0>
db_session = <sqlalchemy.orm.session.Session object at 0x718db9b9a850>

>   ???
E   AssertionError: assert [{'ai_tags': ...[], ...}, ...] == []
E     Left contains 11 more items, first extra item: {'ai_tags': [], 'camera_data': {}, 'category': 'portrait', 'collaborators': [], ...}
E     Full diff:
E       [
E     -  ,
E     +  {'ai_tags': [],
E     +   'camera_data': {},
E     +   'category': 'portrait',...
E     
E     ...Full output truncated (174 lines hidden), use '-vv' to show

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:25: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/recent "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/recent "HTTP/1.1 200 OK"
__________ TestPhotoEndpoints.test_get_recent_photos_with_pagination ___________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e7f490>
client = <starlette.testclient.TestClient object at 0x718db9bae450>

>   ???
E   KeyError: 'pagination'

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:36: KeyError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/recent?page=2&limit=10 "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/recent?page=2&limit=10 "HTTP/1.1 200 OK"
_____________ TestPhotoEndpoints.test_list_photos_public_endpoint ______________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e7fb50>
client = <starlette.testclient.TestClient object at 0x718db9b9b310>

>   ???
E   AssertionError: assert 'pagination' in {'has_more': False, 'limit': 20, 'page': 1, 'photos': [{'ai_tags': [], 'camera_data': {}, 'category': 'portrait', 'collaborators': [], ...}, {'ai_tags': [], 'camera_data': {}, 'category': 'portrait', 'collaborators': [], ...}, {'ai_tags': [], 'camera_data': {}, 'category': 'portrait', 'collaborators': [], ...}, {'ai_tags': [], 'camera_data': {}, 'category': 'portrait', 'collaborators': [], ...}, {'ai_tags': [], 'camera_data': {}, 'category': 'portrait', 'collaborators': [], ...}, {'ai_tags': [], 'camera_data': {}, 'category': 'portrait', 'collaborators': [], ...}, ...], ...}

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:56: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/ "HTTP/1.1 200 OK"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/ "HTTP/1.1 200 OK"
________________ TestPhotoEndpoints.test_get_nonexistent_photo _________________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8c090>
client = <starlette.testclient.TestClient object at 0x718db9aff890>

>   ???
E   assert 403 == 404
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:62: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/nonexistent-photo-id "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/nonexistent-photo-id "HTTP/1.1 403 Forbidden"
_____________ TestPhotoEndpoints.test_get_my_photos_authenticated ______________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8c6d0>
mock_get_user = <AsyncMock name='get_current_user' id='124853389050512'>
client = <starlette.testclient.TestClient object at 0x718db1e77b10>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:78: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
____________ TestPhotoEndpoints.test_get_my_photos_unauthenticated _____________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8cd90>
client = <starlette.testclient.TestClient object at 0x718db0f5bf90>

>   ???
E   assert 403 == 401
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:87: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/my-photos "HTTP/1.1 403 Forbidden"
_______________ TestPhotoEndpoints.test_get_user_photos_endpoint _______________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8d3d0>
mock_get_user = <AsyncMock name='get_current_user' id='124853375695120'>
client = <starlette.testclient.TestClient object at 0x718db11b6d10>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:100: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/user "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/user "HTTP/1.1 403 Forbidden"
_______________ TestPhotoEndpoints.test_get_specific_user_photos _______________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8da90>
client = <starlette.testclient.TestClient object at 0x718db9bad7d0>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:108: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: GET http://testserver/api/v1/photos/user/some-user-id "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: GET http://testserver/api/v1/photos/user/some-user-id "HTTP/1.1 403 Forbidden"
_________________ TestPhotoEndpoints.test_upload_photo_success _________________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8e050>
mock_upload = <AsyncMock name='upload_photo' id='124853374032720'>
mock_get_user = <AsyncMock name='get_current_user' id='124853374040336'>
client = <starlette.testclient.TestClient object at 0x718db10234d0>

>   ???
E   assert 403 == 200
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:146: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: POST http://testserver/api/v1/photos/upload "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: POST http://testserver/api/v1/photos/upload "HTTP/1.1 403 Forbidden"
_____________ TestPhotoEndpoints.test_upload_photo_unauthenticated _____________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8e710>
client = <starlette.testclient.TestClient object at 0x718db17644d0>

>   ???
E   assert 403 == 401
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:159: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: POST http://testserver/api/v1/photos/upload "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: POST http://testserver/api/v1/photos/upload "HTTP/1.1 403 Forbidden"
_______________ TestPhotoEndpoints.test_upload_invalid_file_type _______________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8ed50>
mock_get_user = <AsyncMock name='get_current_user' id='124853378070736'>
client = <starlette.testclient.TestClient object at 0x718db9afee50>

>   ???
E   assert 403 == 400
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:178: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: POST http://testserver/api/v1/photos/upload "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: POST http://testserver/api/v1/photos/upload "HTTP/1.1 403 Forbidden"
______________ TestPhotoEndpoints.test_update_photo_authenticated ______________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8f390>
mock_get_user = <AsyncMock name='get_current_user' id='124853405729360'>
client = <starlette.testclient.TestClient object at 0x718db0e30f90>

>   ???
E   assert 403 in [404, 500]
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:203: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PUT http://testserver/api/v1/photos/test-photo-id "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: PUT http://testserver/api/v1/photos/test-photo-id "HTTP/1.1 403 Forbidden"
_____________ TestPhotoEndpoints.test_update_photo_unauthenticated _____________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8fa50>
client = <starlette.testclient.TestClient object at 0x718db05af4d0>

>   ???
E   assert 403 == 401
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:216: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: PUT http://testserver/api/v1/photos/test-photo-id "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: PUT http://testserver/api/v1/photos/test-photo-id "HTTP/1.1 403 Forbidden"
______________ TestPhotoEndpoints.test_delete_photo_authenticated ______________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e940d0>
mock_get_user = <AsyncMock name='get_current_user' id='124853520340048'>
client = <starlette.testclient.TestClient object at 0x718db1765310>

>   ???
E   assert 403 in [404, 500]
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:230: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: DELETE http://testserver/api/v1/photos/test-photo-id "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: DELETE http://testserver/api/v1/photos/test-photo-id "HTTP/1.1 403 Forbidden"
_____________ TestPhotoEndpoints.test_delete_photo_unauthenticated _____________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e94790>
client = <starlette.testclient.TestClient object at 0x718db1c3ca90>

>   ???
E   assert 403 == 401
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:236: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: DELETE http://testserver/api/v1/photos/test-photo-id "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: DELETE http://testserver/api/v1/photos/test-photo-id "HTTP/1.1 403 Forbidden"
______________ TestPhotoEndpoints.test_like_photo_not_implemented ______________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e94dd0>
mock_get_user = <AsyncMock name='get_current_user' id='124853386726672'>
client = <starlette.testclient.TestClient object at 0x718db1c3c990>

>   ???
E   assert 403 == 501
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:249: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: POST http://testserver/api/v1/photos/test-photo-id/like "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: POST http://testserver/api/v1/photos/test-photo-id/like "HTTP/1.1 403 Forbidden"
____________ TestPhotoEndpoints.test_search_photos_not_implemented _____________

self = <tests.integration.test_photo_endpoints.TestPhotoEndpoints object at 0x718db2e8f710>
client = <starlette.testclient.TestClient object at 0x718db1401890>

>   ???
E   assert 403 == 501
E    +  where 403 = <Response [403 Forbidden]>.status_code

/home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_photo_endpoints.py:262: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO:httpx:HTTP Request: POST http://testserver/api/v1/photos/search "HTTP/1.1 403 Forbidden"
------------------------------ Captured log call -------------------------------
INFO     httpx:_client.py:1013 HTTP Request: POST http://testserver/api/v1/photos/search "HTTP/1.1 403 Forbidden"
________________ TestUserDeletion.test_delete_nonexistent_user _________________

args = (), kwargs = {}
coro = <coroutine object TestUserDeletion.test_delete_nonexistent_user at 0x718db2472d40>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
____________ TestUserDeletion.test_gmail_profile_image_not_deleted _____________

args = ()
kwargs = {'mock_user': <User(handle='test_handle', display_name='Test User')>}
coro = <coroutine object TestUserDeletion.test_gmail_profile_image_not_deleted at 0x718db2ea5480>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
_________________ TestUserDeletion.test_orphaned_photos_check __________________

args = (), kwargs = {}
coro = <coroutine object TestUserDeletion.test_orphaned_photos_check at 0x718db2df2c00>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
_______________ test_delete_user_endpoint_requires_confirmation ________________

args = ()
kwargs = {'auth_headers': {'Authorization': 'Bearer test-firebase-token-123'}, 'client': <starlette.testclient.TestClient object at 0x718db2cfddd0>}
coro = <coroutine object test_delete_user_endpoint_requires_confirmation at 0x718db2df39c0>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
_______________ TestAuthMiddleware.test_get_current_user_success _______________

args = (), kwargs = {}
coro = <coroutine object TestAuthMiddleware.test_get_current_user_success at 0x718db2deec30>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
____________ TestAuthMiddleware.test_get_current_user_invalid_token ____________

args = (), kwargs = {}
coro = <coroutine object TestAuthMiddleware.test_get_current_user_invalid_token at 0x718db1f26fb0>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
_________ TestAuthMiddleware.test_get_current_user_firebase_exception __________

args = (), kwargs = {}
coro = <coroutine object TestAuthMiddleware.test_get_current_user_firebase_exception at 0x718db1f26430>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
______________ TestAuthMiddleware.test_get_optional_user_success _______________

args = (), kwargs = {}
coro = <coroutine object TestAuthMiddleware.test_get_optional_user_success at 0x718db2dedf20>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
___________ TestAuthMiddleware.test_get_optional_user_no_credentials ___________

args = (), kwargs = {}
coro = <coroutine object TestAuthMiddleware.test_get_optional_user_no_credentials at 0x718db130e570>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
___________ TestAuthMiddleware.test_get_optional_user_invalid_token ____________

args = (), kwargs = {}
coro = <coroutine object TestAuthMiddleware.test_get_optional_user_invalid_token at 0x718db2deed60>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
_______ TestAuthMiddleware.test_get_optional_user_firebase_returns_none ________

args = (), kwargs = {}
coro = <coroutine object TestAuthMiddleware.test_get_optional_user_firebase_returns_none at 0x718db2dee510>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
_ TestAuthMiddlewareIntegration.test_middleware_with_fastapi_dependency_injection _

args = (), kwargs = {}
coro = <coroutine object TestAuthMiddlewareIntegration.test_middleware_with_fastapi_dependency_injection at 0x718db31434c0>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
___________________ TestPhotoModel.test_photo_model_creation ___________________

self = <sqlalchemy.engine.base.Connection object at 0x718db1c76ad0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1c77250>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db1e6df50>
parameters = [{'camera_data': '{"make": "Canon", "model": "EOS R5", "settings": {"iso": 100, "aperture": 2.8, "shutter": "1/60", "focal_length": 50}}', 'category': 'portrait', 'city_id': None, 'content_rating': 'general', ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db22576a0; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, camera_data, u..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'camera_data': '{"make": "Canon", "model": "EOS R5", "settings": {"iso": 100, "aperture": 2.8, "shutter": "1/60", "focal_length": 50}}', 'category': 'portrait', 'city_id': None, 'content_rating': 'general', ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1c77250>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DatatypeMismatch: column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ...rtrait','studio']::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: DatatypeMismatch

The above exception was the direct cause of the following exception:

self = <tests.unit.test_photo_model.TestPhotoModel object at 0x718db2efe290>
db_session = <sqlalchemy.orm.session.Session object at 0x718db05c3310>
sample_photo_data = {'camera_data': {'make': 'Canon', 'model': 'EOS R5', 'settings': {'aperture': 2.8, 'focal_length': 50, 'iso': 100, 'sh...scription': 'A test photo for unit testing', 'image_url': 'https://example.com/test-photo.jpg', 'is_public': True, ...}

    def test_photo_model_creation(self, db_session, sample_photo_data):
        """Test creating a Photo model instance."""
        # Create a user first (required for foreign key)
        user_id = "firebase-uid-12345678901234567890"
    
        photo = Photo(
            user_id=user_id,
            title=sample_photo_data["title"],
            description=sample_photo_data["description"],
            image_url=sample_photo_data["image_url"],
            camera_data=sample_photo_data["camera_data"],
            user_tags=sample_photo_data["user_tags"],
            is_public=sample_photo_data["is_public"]
        )
    
        db_session.add(photo)
>       db_session.commit()

scripts/tests/unit/test_photo_model.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db22576a0; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, camera_data, u..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'camera_data': '{"make": "Canon", "model": "EOS R5", "settings": {"iso": 100, "aperture": 2.8, "shutter": "1/60", "focal_length": 50}}', 'category': 'portrait', 'city_id': None, 'content_rating': 'general', ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1c77250>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DatatypeMismatch) column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ...rtrait','studio']::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.
E       
E       [SQL: INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, camera_data, user_tags, content_rating, category, series_id, is_deleted, is_public, view_count, is_collaborative, model_release_status, extra_metadata, is_portfolio, status) VALUES (%(id)s::UUID, %(user_id)s, %(title)s, %(description)s, %(image_url)s, %(thumbnail_url)s, %(city_id)s, %(location_name)s, %(camera_data)s, %(user_tags)s::TEXT[], %(content_rating)s, %(category)s, %(series_id)s::UUID, %(is_deleted)s, %(is_public)s, %(view_count)s, %(is_collaborative)s, %(model_release_status)s, %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at]
E       [parameters: {'id': UUID('44b0277d-0140-4947-87c3-42d21608bb81'), 'user_id': 'firebase-uid-12345678901234567890', 'title': 'Test Photo', 'description': 'A test photo for unit testing', 'image_url': 'https://example.com/test-photo.jpg', 'thumbnail_url': None, 'city_id': None, 'location_name': None, 'camera_data': '{"make": "Canon", "model": "EOS R5", "settings": {"iso": 100, "aperture": 2.8, "shutter": "1/60", "focal_length": 50}}', 'user_tags': ['portrait', 'studio'], 'content_rating': 'general', 'category': 'portrait', 'series_id': None, 'is_deleted': False, 'is_public': True, 'view_count': 0, 'is_collaborative': False, 'model_release_status': 'none', 'extra_metadata': '{}', 'is_portfolio': False, 'status': 'active'}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: ProgrammingError
___________________ TestPhotoModel.test_photo_default_values ___________________

self = <sqlalchemy.engine.base.Connection object at 0x718db1a00fd0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1f9d450>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db1e384d0>
parameters = [{'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db2257010; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1f9d450>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DatatypeMismatch: column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ... NULL, NULL, NULL::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: DatatypeMismatch

The above exception was the direct cause of the following exception:

self = <tests.unit.test_photo_model.TestPhotoModel object at 0x718db2efe610>
db_session = <sqlalchemy.orm.session.Session object at 0x718db1a02790>

    def test_photo_default_values(self, db_session):
        """Test Photo model default values."""
        user_id = "firebase-uid-default-test-123"
    
        photo = Photo(
            user_id=user_id,
            image_url="https://example.com/test-default.jpg"
        )
    
        db_session.add(photo)
>       db_session.commit()

scripts/tests/unit/test_photo_model.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db2257010; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db1f9d450>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DatatypeMismatch) column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ... NULL, NULL, NULL::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.
E       
E       [SQL: INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, content_rating, category, series_id, is_deleted, is_public, view_count, is_collaborative, model_release_status, extra_metadata, is_portfolio, status) VALUES (%(id)s::UUID, %(user_id)s, %(title)s, %(description)s, %(image_url)s, %(thumbnail_url)s, %(city_id)s, %(location_name)s, %(user_tags)s::TEXT[], %(content_rating)s, %(category)s, %(series_id)s::UUID, %(is_deleted)s, %(is_public)s, %(view_count)s, %(is_collaborative)s, %(model_release_status)s, %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at]
E       [parameters: {'id': UUID('664d8377-5340-4d8f-b2bc-39e46608ce26'), 'user_id': 'firebase-uid-default-test-123', 'title': None, 'description': None, 'image_url': 'https://example.com/test-default.jpg', 'thumbnail_url': None, 'city_id': None, 'location_name': None, 'user_tags': None, 'content_rating': 'general', 'category': 'portrait', 'series_id': None, 'is_deleted': False, 'is_public': True, 'view_count': 0, 'is_collaborative': False, 'model_release_status': 'none', 'extra_metadata': '{}', 'is_portfolio': False, 'status': 'active'}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: ProgrammingError
________________________ TestPhotoModel.test_photo_repr ________________________

self = <sqlalchemy.engine.base.Connection object at 0x718db21237d0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db2122c10>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db1e384d0>
parameters = [{'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db1a68130; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db2122c10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.DatatypeMismatch: column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ... NULL, NULL, NULL::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: DatatypeMismatch

The above exception was the direct cause of the following exception:

self = <tests.unit.test_photo_model.TestPhotoModel object at 0x718db2efe990>
db_session = <sqlalchemy.orm.session.Session object at 0x718db0090610>

    def test_photo_repr(self, db_session):
        """Test Photo __repr__ method."""
        user_id = "firebase-uid-repr-test-1234"
    
        photo = Photo(
            user_id=user_id,
            title="Test Photo",
            image_url="https://example.com/test-photo.jpg"
        )
    
        db_session.add(photo)
>       db_session.commit()

scripts/tests/unit/test_photo_model.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db1a68130; closed: -1>
statement = 'INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, con..., %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at'
parameters = {'category': 'portrait', 'city_id': None, 'content_rating': 'general', 'description': None, ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db2122c10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.DatatypeMismatch) column "series_id" is of type integer but expression is of type uuid
E       LINE 1: ... NULL, NULL, NULL::TEXT[], 'general', 'portrait', NULL::UUID...
E                                                                    ^
E       HINT:  You will need to rewrite or cast the expression.
E       
E       [SQL: INSERT INTO photos (id, user_id, title, description, image_url, thumbnail_url, city_id, location_name, user_tags, content_rating, category, series_id, is_deleted, is_public, view_count, is_collaborative, model_release_status, extra_metadata, is_portfolio, status) VALUES (%(id)s::UUID, %(user_id)s, %(title)s, %(description)s, %(image_url)s, %(thumbnail_url)s, %(city_id)s, %(location_name)s, %(user_tags)s::TEXT[], %(content_rating)s, %(category)s, %(series_id)s::UUID, %(is_deleted)s, %(is_public)s, %(view_count)s, %(is_collaborative)s, %(model_release_status)s, %(extra_metadata)s, %(is_portfolio)s, %(status)s) RETURNING photos.upload_date, photos.created_at, photos.updated_at]
E       [parameters: {'id': UUID('38454183-945b-4c76-92fc-c9e9cc7ecd16'), 'user_id': 'firebase-uid-repr-test-1234', 'title': 'Test Photo', 'description': None, 'image_url': 'https://example.com/test-photo.jpg', 'thumbnail_url': None, 'city_id': None, 'location_name': None, 'user_tags': None, 'content_rating': 'general', 'category': 'portrait', 'series_id': None, 'is_deleted': False, 'is_public': True, 'view_count': 0, 'is_collaborative': False, 'model_release_status': 'none', 'extra_metadata': '{}', 'is_portfolio': False, 'status': 'active'}]
E       (Background on this error at: https://sqlalche.me/e/20/f405)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: ProgrammingError
___________________ TestPhotoModel.test_like_count_property ____________________

self = <tests.unit.test_photo_model.TestPhotoModel object at 0x718db2efef10>

    def test_like_count_property(self):
        """Test like_count property calculation."""
        photo = Photo(
            user_id="firebase-uid-like-test-12345",
            image_url="https://example.com/like-test.jpg"
        )
    
        # Mock interactions
        mock_like1 = Mock()
        mock_like1.interaction_type = "like"
    
        mock_like2 = Mock()
        mock_like2.interaction_type = "like"
    
        mock_save = Mock()
        mock_save.interaction_type = "save"
    
>       photo.interactions = [mock_like1, mock_like2, mock_save]

scripts/tests/unit/test_photo_model.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1abd430>
child = <Mock id='124853362869584'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245dd80>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853362873616'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
_______________ TestPhotoModel.test_collaborator_names_property ________________

self = <tests.unit.test_photo_model.TestPhotoModel object at 0x718db2eff5d0>

    def test_collaborator_names_property(self):
        """Test collaborator_names property."""
        photo = Photo(
            user_id="firebase-uid-like-test-12345",
            image_url="https://example.com/like-test.jpg"
        )
    
        # Mock collaborators
        mock_collab1 = Mock()
        mock_collab1.display_name = "Jane Doe"
    
        mock_collab2 = Mock()
        mock_collab2.display_name = "John Smith"
    
>       photo.collaborators = [mock_collab1, mock_collab2]

scripts/tests/unit/test_photo_model.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1ca1970>
child = <Mock id='124853383249104'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245e900>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853383234448'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
_____ TestPhotoModel.test_photographer_name_property_owner_is_photographer _____

self = <tests.unit.test_photo_model.TestPhotoModel object at 0x718db2effc90>

    def test_photographer_name_property_owner_is_photographer(self):
        """Test photographer_name when owner is photographer."""
        photo = Photo(
            user_id="firebase-uid-like-test-12345",
            image_url="https://example.com/like-test.jpg"
        )
    
        # Mock user as photographer
        mock_user = Mock()
        mock_user.display_name = "Photographer User"
        mock_user.is_photographer = True
>       photo.user = mock_user

scripts/tests/unit/test_photo_model.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db20be090>
child = <Mock id='124853384392464'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24d2dc0>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853384391312'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_ TestPhotoModel.test_photographer_name_property_collaborator_is_photographer __

self = <tests.unit.test_photo_model.TestPhotoModel object at 0x718db2d08390>

    def test_photographer_name_property_collaborator_is_photographer(self):
        """Test photographer_name when collaborator is photographer."""
        photo = Photo(
            user_id="firebase-uid-like-test-12345",
            image_url="https://example.com/like-test.jpg"
        )
    
        # Mock user as model
        mock_user = Mock()
        mock_user.display_name = "Model User"
        mock_user.is_photographer = False
>       photo.user = mock_user

scripts/tests/unit/test_photo_model.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db20bc770>
child = <Mock id='124853384573392'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24d2dc0>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853384571280'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
________________ TestPhotoModel.test_location_display_property _________________

self = <tests.unit.test_photo_model.TestPhotoModel object at 0x718db2d08a50>

    def test_location_display_property(self):
        """Test location_display property with different combinations."""
        photo = Photo(
            user_id="firebase-uid-like-test-12345",
            image_url="https://example.com/like-test.jpg"
        )
    
        # Mock city
        mock_city = Mock()
        mock_city.name = "New York"
        mock_city.country = "USA"
    
        # Test with location name and city
        photo.location_name = "Central Park"
>       photo.city = mock_city

scripts/tests/unit/test_photo_model.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db20bebd0>
child = <Mock id='124853391531344'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db24e4e00>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853391530384'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
____________________ TestPhotoModel.test_is_liked_by_method ____________________

self = <tests.unit.test_photo_model.TestPhotoModel object at 0x718db2d09e50>

    def test_is_liked_by_method(self):
        """Test is_liked_by method."""
        photo = Photo(
            user_id="firebase-uid-like-test-12345",
            image_url="https://example.com/like-test.jpg"
        )
        test_user_id = "firebase-uid-test-user-123"
        other_user_id = "firebase-uid-other-user-456"
    
        # Mock interactions
        mock_like = Mock()
        mock_like.user_id = test_user_id
        mock_like.interaction_type = "like"
    
        mock_save = Mock()
        mock_save.user_id = test_user_id
        mock_save.interaction_type = "save"
    
        mock_other_like = Mock()
        mock_other_like.user_id = other_user_id
        mock_other_like.interaction_type = "like"
    
>       photo.interactions = [mock_like, mock_save, mock_other_like]

scripts/tests/unit/test_photo_model.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1989: in set
    collections.bulk_replace(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:803: in bulk_replace
    appender(member, _sa_initiator=initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1130: in append
    item = __set(self, item, _sa_initiator, NO_KEY)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:1095: in __set
    item = executor.fire_append_event(item, _sa_initiator, key=key)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/collections.py:687: in fire_append_event
    return self.attr.fire_append_event(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1756: in fire_append_event
    value = fn(state, value, initiator or self._append_token, key=key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db2082390>
child = <Mock id='124853372890256'>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db245dd80>
kw = {'key': <EventConstants.NO_KEY: 4>}
child_state = <Mock name='mock._sa_instance_state' id='124853372890768'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_collection_append_event(
        state, child, initiator, **kw
    ):
        if child is None:
            return
    
        child_state, child_dict = instance_state(child), instance_dict(child)
>       child_impl = child_state.manager[key].impl
E       TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2207: TypeError
____________________ TestUserModel.test_user_model_creation ____________________

self = <sqlalchemy.engine.base.Connection object at 0x718db00ff1d0>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db00ffb10>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db00fe590>
parameters = [{'age': None, 'availability_data': '{}', 'bio': 'Test photographer', 'birth_date': datetime.date(1990, 1, 1), ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db22576a0; closed: -1>
statement = 'INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepte...ier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active'
parameters = {'age': None, 'availability_data': '{}', 'bio': 'Test photographer', 'birth_date': datetime.date(1990, 1, 1), ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db00ffb10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "users_email_key"
E       DETAIL:  Key (email)=(test@example.com) already exists.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: UniqueViolation

The above exception was the direct cause of the following exception:

self = <tests.unit.test_user_model.TestUserModel object at 0x718db2d0df50>
db_session = <sqlalchemy.orm.session.Session object at 0x718db1d8d450>
sample_user_data = {'bio': 'Test photographer', 'birth_date': datetime.date(1990, 1, 1), 'city_id': 1, 'country_code': 'US', ...}

    def test_user_model_creation(self, db_session, sample_user_data):
        """Test creating a User model instance."""
        user = User(
            id=sample_user_data["id"],
            email=sample_user_data["email"],
            handle=sample_user_data["handle"],
            display_name=sample_user_data["display_name"],
            city_id=sample_user_data["city_id"],
            primary_user_type=sample_user_data["primary_user_type"],
            birth_date=sample_user_data["birth_date"],
            country_code=sample_user_data["country_code"],
            tos_accepted_at=sample_user_data["tos_accepted_at"],
            bio=sample_user_data["bio"],
            profile_data=sample_user_data["profile_data"]
        )
    
        db_session.add(user)
>       db_session.commit()

scripts/tests/unit/test_user_model.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db22576a0; closed: -1>
statement = 'INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepte...ier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active'
parameters = {'age': None, 'availability_data': '{}', 'bio': 'Test photographer', 'birth_date': datetime.date(1990, 1, 1), ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db00ffb10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (psycopg2.errors.UniqueViolation) duplicate key value violates unique constraint "users_email_key"
E       DETAIL:  Key (email)=(test@example.com) already exists.
E       
E       [SQL: INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepted_at, gender, age, height_cm, weight_kg, ethnicity, eye_color, hair_color, has_tattoos, has_piercings, profile_image_url, bio, website, profile_data, availability_data, privacy_settings, stripe_customer_id, stripe_subscription_id, subscription_tier, subscription_status, subscription_data) VALUES (%(id)s, %(email)s, %(handle)s, %(display_name)s, %(city_id)s, %(primary_user_type)s, %(birth_date)s, %(country_code)s, %(tos_accepted_at)s, %(gender)s, %(age)s, %(height_cm)s, %(weight_kg)s, %(ethnicity)s, %(eye_color)s, %(hair_color)s, %(has_tattoos)s, %(has_piercings)s, %(profile_image_url)s, %(bio)s, %(website)s, %(profile_data)s, %(availability_data)s, %(privacy_settings)s, %(stripe_customer_id)s, %(stripe_subscription_id)s, %(subscription_tier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active]
E       [parameters: {'id': 'test-firebase-uid-123456789', 'email': 'test@example.com', 'handle': 'testuser', 'display_name': 'Test User', 'city_id': 1, 'primary_user_type': 1, 'birth_date': datetime.date(1990, 1, 1), 'country_code': 'US', 'tos_accepted_at': datetime.datetime(2025, 9, 21, 3, 59, 52, 450155), 'gender': None, 'age': None, 'height_cm': None, 'weight_kg': None, 'ethnicity': None, 'eye_color': None, 'hair_color': None, 'has_tattoos': False, 'has_piercings': False, 'profile_image_url': None, 'bio': 'Test photographer', 'website': None, 'profile_data': '{"portfolio_url": "https://example.com"}', 'availability_data': '{}', 'privacy_settings': '{"show_city": false, "show_country": true, "show_age": true}', 'stripe_customer_id': None, 'stripe_subscription_id': None, 'subscription_tier': 'free', 'subscription_status': 'active', 'subscription_data': '{}'}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: IntegrityError
____________________ TestUserModel.test_user_default_values ____________________

self = <sqlalchemy.engine.base.Connection object at 0x718db0f08f50>
dialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db12f1510>
statement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x718db2366f50>
parameters = [{'age': None, 'availability_data': '{}', 'bio': None, 'birth_date': datetime.date(1990, 1, 1), ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db16f0220; closed: -1>
statement = 'INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepte...ier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active'
parameters = {'age': None, 'availability_data': '{}', 'bio': None, 'birth_date': datetime.date(1990, 1, 1), ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db12f1510>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "users_email_key"
E       DETAIL:  Key (email)=(defaults@example.com) already exists.

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: UniqueViolation

The above exception was the direct cause of the following exception:

self = <tests.unit.test_user_model.TestUserModel object at 0x718db2d0e650>
db_session = <sqlalchemy.orm.session.Session object at 0x718db0f0b0d0>

    def test_user_default_values(self, db_session):
        """Test User model default values."""
        user = User(
            id="test-uid-defaults-12345678",
            email="defaults@example.com",
            handle="defaultuser",
            display_name="Default User",
            city_id=1,
            primary_user_type=1,
            birth_date=datetime(1990, 1, 1).date(),
            country_code="US",
            tos_accepted_at=datetime.now()
        )
    
        db_session.add(user)
>       db_session.commit()

scripts/tests/unit/test_user_model.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1969: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1256: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1231: in _prepare_impl
    self.session.flush()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4312: in flush
    self._flush(objects)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4447: in _flush
    with util.safe_reraise():
backend/venv/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:146: in __exit__
    raise exc_value.with_traceback(exc_tb)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/session.py:4408: in _flush
    flush_context.execute()
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:466: in execute
    rec.execute(self)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:93: in save_obj
    _emit_insert_statements(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/persistence.py:1226: in _emit_insert_statements
    result = connection.execute(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1416: in execute
    return meth(
backend/venv/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:516: in _execute_on_connection
    return connection._execute_clauseelement(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1639: in _execute_clauseelement
    ret = self._execute_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1848: in _execute_context
    return self._exec_single_context(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1988: in _exec_single_context
    self._handle_dbapi_exception(
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2343: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1969: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x718db82c0cd0>
cursor = <cursor object at 0x718db16f0220; closed: -1>
statement = 'INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepte...ier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active'
parameters = {'age': None, 'availability_data': '{}', 'bio': None, 'birth_date': datetime.date(1990, 1, 1), ...}
context = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x718db12f1510>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (psycopg2.errors.UniqueViolation) duplicate key value violates unique constraint "users_email_key"
E       DETAIL:  Key (email)=(defaults@example.com) already exists.
E       
E       [SQL: INSERT INTO users (id, email, handle, display_name, city_id, primary_user_type, birth_date, country_code, tos_accepted_at, gender, age, height_cm, weight_kg, ethnicity, eye_color, hair_color, has_tattoos, has_piercings, profile_image_url, bio, website, profile_data, availability_data, privacy_settings, stripe_customer_id, stripe_subscription_id, subscription_tier, subscription_status, subscription_data) VALUES (%(id)s, %(email)s, %(handle)s, %(display_name)s, %(city_id)s, %(primary_user_type)s, %(birth_date)s, %(country_code)s, %(tos_accepted_at)s, %(gender)s, %(age)s, %(height_cm)s, %(weight_kg)s, %(ethnicity)s, %(eye_color)s, %(hair_color)s, %(has_tattoos)s, %(has_piercings)s, %(profile_image_url)s, %(bio)s, %(website)s, %(profile_data)s, %(availability_data)s, %(privacy_settings)s, %(stripe_customer_id)s, %(stripe_subscription_id)s, %(subscription_tier)s, %(subscription_status)s, %(subscription_data)s) RETURNING users.created_at, users.updated_at, users.last_active]
E       [parameters: {'id': 'test-uid-defaults-12345678', 'email': 'defaults@example.com', 'handle': 'defaultuser', 'display_name': 'Default User', 'city_id': 1, 'primary_user_type': 1, 'birth_date': datetime.date(1990, 1, 1), 'country_code': 'US', 'tos_accepted_at': datetime.datetime(2025, 9, 21, 3, 59, 52, 745018), 'gender': None, 'age': None, 'height_cm': None, 'weight_kg': None, 'ethnicity': None, 'eye_color': None, 'hair_color': None, 'has_tattoos': False, 'has_piercings': False, 'profile_image_url': None, 'bio': None, 'website': None, 'profile_data': '{}', 'availability_data': '{}', 'privacy_settings': '{"show_city": false, "show_country": true, "show_age": true}', 'stripe_customer_id': None, 'stripe_subscription_id': None, 'subscription_tier': 'free', 'subscription_status': 'active', 'subscription_data': '{}'}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

backend/venv/lib/python3.11/site-packages/sqlalchemy/engine/default.py:922: IntegrityError
___________________ TestUserModel.test_user_type_properties ____________________

self = <tests.unit.test_user_model.TestUserModel object at 0x718db2d0f410>

    def test_user_type_properties(self):
        """Test user type checking properties."""
        # Mock user type relationships
        photographer_type = Mock()
        photographer_type.type_name = "photographer"
    
        model_type = Mock()
        model_type.type_name = "model"
    
        # Test photographer
        user = User(
            id="test-photographer-123456789",
            email="photo@example.com",
            handle="photographer",
            display_name="Test Photographer",
            city_id=1,
            primary_user_type=1,
            birth_date=datetime(1985, 1, 1).date(),
            country_code="US",
            tos_accepted_at=datetime.now()
        )
>       user.user_type = photographer_type

scripts/tests/unit/test_user_model.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db117b410>
child = <Mock id='124853362909136'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853362916176'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_______________ TestUserModel.test_location_display_with_privacy _______________

self = <tests.unit.test_user_model.TestUserModel object at 0x718db2d0fad0>

    def test_location_display_with_privacy(self):
        """Test location display respects privacy settings."""
        # Mock city relationship
        mock_city = Mock()
        mock_city.name = "New York"
        mock_city.country = "USA"
    
        user = User(
            id="test-location-1234567890",
            email="location@example.com",
            handle="locationuser",
            display_name="Location User",
            city_id=1,
            primary_user_type=1,
            birth_date=datetime(1990, 1, 1).date(),
            country_code="US",
            tos_accepted_at=datetime.now()
        )
>       user.city = mock_city

scripts/tests/unit/test_user_model.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1c37530>
child = <Mock id='124853520082448'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2466d00>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853520083600'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_______________ TestUserModel.test_model_validation_requirements _______________

self = <tests.unit.test_user_model.TestUserModel object at 0x718db2d2c1d0>

    def test_model_validation_requirements(self):
        """Test model-specific field validation."""
        # Mock model type
        model_type = Mock()
        model_type.type_name = "model"
    
        user = User(
            id="test-model-12345678901234",
            email="model@example.com",
            handle="testmodel",
            display_name="Test Model",
            city_id=1,
            primary_user_type=1,
            birth_date=datetime(1995, 1, 1).date(),
            country_code="US",
            tos_accepted_at=datetime.now()
        )
>       user.user_type = model_type

scripts/tests/unit/test_user_model.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db1c351f0>
child = <Mock id='124853381926928'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853381938064'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
___________ TestUserModel.test_photographer_validation_requirements ____________

self = <tests.unit.test_user_model.TestUserModel object at 0x718db2d2c890>

    def test_photographer_validation_requirements(self):
        """Test photographer doesn't need model-specific fields."""
        # Mock photographer type
        photographer_type = Mock()
        photographer_type.type_name = "photographer"
    
        user = User(
            id="test-photographer-validation",
            email="photovalidation@example.com",
            handle="photouser",
            display_name="Photo User",
            city_id=1,
            primary_user_type=1,
            birth_date=datetime(1988, 1, 1).date(),
            country_code="US",
            tos_accepted_at=datetime.now()
        )
>       user.user_type = photographer_type

scripts/tests/unit/test_user_model.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:537: in __set__
    self.impl.set(
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1467: in set
    value = self.fire_replace_event(state, dict_, value, old, initiator)
backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:1506: in fire_replace_event
    value = fn(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

state = <sqlalchemy.orm.state.InstanceState object at 0x718db20a33b0>
child = <Mock id='124853391163664'>
oldchild = <LoaderCallableStatus.NO_VALUE: 4>
initiator = <sqlalchemy.orm.attributes.AttributeEventToken object at 0x718db2460240>
kw = {}
child_state = <Mock name='mock._sa_instance_state' id='124853391172880'>
child_dict = {'_mock_call_args': None, '_mock_call_args_list': [], '_mock_call_count': 0, '_mock_called': False, ...}

    def emit_backref_from_scalar_set_event(
        state, child, oldchild, initiator, **kw
    ):
        if oldchild is child:
            return child
        if (
            oldchild is not None
            and oldchild is not PASSIVE_NO_RESULT
            and oldchild is not NO_VALUE
        ):
            # With lazy=None, there's no guarantee that the full collection is
            # present when updating via a backref.
            old_state, old_dict = (
                instance_state(oldchild),
                instance_dict(oldchild),
            )
            impl = old_state.manager[key].impl
    
            # tokens to test for a recursive loop.
            if not impl.collection and not impl.dynamic:
                check_recursive_token = impl._replace_token
            else:
                check_recursive_token = impl._remove_token
    
            if initiator is not check_recursive_token:
                impl.pop(
                    old_state,
                    old_dict,
                    state.obj(),
                    parent_impl._append_token,
                    passive=PASSIVE_NO_FETCH,
                )
    
        if child is not None:
            child_state, child_dict = (
                instance_state(child),
                instance_dict(child),
            )
>           child_impl = child_state.manager[key].impl
E           TypeError: 'Mock' object is not subscriptable

backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/attributes.py:2171: TypeError
_______________ TestUserPydanticModels.test_user_profile_models ________________

self = <tests.unit.test_user_model.TestUserPydanticModels object at 0x718db2d2c810>

    def test_user_profile_models(self):
        """Test user profile response models."""
        # Public profile
        public_profile = UserProfilePublic(
            id="test-user-id",
            handle="testuser",
            display_name="Test User",
            bio="Test bio",
            city_name="New York",
            user_type="photographer",
            photography_styles=["portrait", "fashion"],
            portfolio_count=15,
            is_verified=True
        )
    
        assert public_profile.id == "test-user-id"
        assert public_profile.handle == "testuser"
        assert public_profile.portfolio_count == 15
    
        # Private profile extends public
        private_profile = UserProfilePrivate(
            id="test-user-id",
            handle="testuser",
            display_name="Test User",
            user_type="photographer",
            email="test@example.com",
            firebase_uid="firebase-uid-123",
            privacy_settings={"show_city": False}
        )
    
        assert private_profile.email == "test@example.com"
>       assert private_profile.firebase_uid == "firebase-uid-123"

scripts/tests/unit/test_user_model.py:334: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = UserProfilePrivate(id='test-user-id', handle='testuser', display_name='Test User', bio=None, profile_image_url=None, c...r_travel=False, location_preferences=[], website=None, email='test@example.com', privacy_settings={'show_city': False})
item = 'firebase_uid'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra is not None:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'UserProfilePrivate' object has no attribute 'firebase_uid'

backend/venv/lib/python3.11/site-packages/pydantic/main.py:761: AttributeError
___ TestEnhancedUserService.test_update_user_profile_with_artistic_statement ___

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_update_user_profile_with_artistic_statement at 0x718db130eac0>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
_ TestEnhancedUserService.test_update_user_profile_photographer_specific_fields _

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_update_user_profile_photographer_specific_fields at 0x718db130e570>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
____ TestEnhancedUserService.test_update_user_profile_model_specific_fields ____

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_update_user_profile_model_specific_fields at 0x718db130e020>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
______ TestEnhancedUserService.test_update_user_profile_availability_data ______

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_update_user_profile_availability_data at 0x718db130de00>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
__________ TestEnhancedUserService.test_upload_profile_image_success ___________

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_upload_profile_image_success at 0x718db130d690>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
__________ TestEnhancedUserService.test_upload_profile_image_failure ___________

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_upload_profile_image_failure at 0x718db130d140>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
____________ TestEnhancedUserService.test_update_profile_image_url _____________

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_update_profile_image_url at 0x718db130ece0>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
______________ TestEnhancedUserService.test_remove_profile_image _______________

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_remove_profile_image at 0x718db130e020>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
___________________ TestEnhancedUserService.test_user_exists ___________________

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_user_exists at 0x718db130e570>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
_________________ TestEnhancedUserService.test_get_user_stats __________________

args = (), kwargs = {}
coro = <coroutine object TestEnhancedUserService.test_get_user_stats at 0x718db130eac0>

    @functools.wraps(func)
    def inner(*args, **kwargs):
        coro = func(*args, **kwargs)
        if not inspect.isawaitable(coro):
            pyfuncitem.warn(
                pytest.PytestWarning(
                    f"The test {pyfuncitem} is marked with '@pytest.mark.asyncio' "
                    "but it is not an async function. "
                    "Please remove asyncio marker. "
                    "If the test is not marked explicitly, "
                    "check for global markers applied via 'pytestmark'."
                )
            )
            return
>       task = asyncio.ensure_future(coro, loop=_loop)

backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:530: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.11/asyncio/tasks.py:659: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
/usr/lib/python3.11/asyncio/tasks.py:680: in _ensure_future
    return loop.create_task(coro_or_future)
/usr/lib/python3.11/asyncio/base_events.py:435: in create_task
    self._check_closed()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_UnixSelectorEventLoop running=False closed=True debug=False>

    def _check_closed(self):
        if self._closed:
>           raise RuntimeError('Event loop is closed')
E           RuntimeError: Event loop is closed

/usr/lib/python3.11/asyncio/base_events.py:520: RuntimeError
=============================== warnings summary ===============================
backend/app/api/endpoints/auth.py:106
  /home/cdc/Storage/NVMe/projects/lumen/backend/app/api/endpoints/auth.py:106: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.5/migration/
    @validator('display_name')

backend/app/api/endpoints/auth.py:112
  /home/cdc/Storage/NVMe/projects/lumen/backend/app/api/endpoints/auth.py:112: PydanticDeprecatedSince20: Pydantic V1 style `@validator` validators are deprecated. You should migrate to Pydantic V2 style `@field_validator` validators, see the migration guide for more details. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.5/migration/
    @validator('user_type')

backend/app/database/connection.py:65
  /home/cdc/Storage/NVMe/projects/lumen/backend/app/database/connection.py:65: MovedIn20Warning: The ``declarative_base()`` function is now available as sqlalchemy.orm.declarative_base(). (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    Base = declarative_base()

backend/venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:268
backend/venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:268
backend/venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:268
backend/venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:268
backend/venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:268
backend/venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:268
  /home/cdc/Storage/NVMe/projects/lumen/backend/venv/lib/python3.11/site-packages/pydantic/_internal/_config.py:268: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.5/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

backend/venv/lib/python3.11/site-packages/pydantic/_internal/_fields.py:149
  /home/cdc/Storage/NVMe/projects/lumen/backend/venv/lib/python3.11/site-packages/pydantic/_internal/_fields.py:149: UserWarning: Field "model_release_status" has conflict with protected namespace "model_".
  
  You may be able to resolve this warning by setting `model_config['protected_namespaces'] = ()`.
    warnings.warn(

backend/venv/lib/python3.11/site-packages/stripe/app_info.py:5
  /home/cdc/Storage/NVMe/projects/lumen/backend/venv/lib/python3.11/site-packages/stripe/app_info.py:5: DeprecationWarning: 
      The stripe.app_info package is deprecated, please change your
      imports to import from stripe directly.
      From:
        from stripe.app_info import AppInfo
      To:
        from stripe import AppInfo
      
    warn(

backend/tests/test_database_integration.py:17
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_database_integration.py:17: PytestUnknownMarkWarning: Unknown pytest.mark.database - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/test_database_integration.py:51
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_database_integration.py:51: PytestUnknownMarkWarning: Unknown pytest.mark.database - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/test_database_integration.py:121
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_database_integration.py:121: PytestUnknownMarkWarning: Unknown pytest.mark.database - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/test_user_service.py:14
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:14: PytestUnknownMarkWarning: Unknown pytest.mark.users - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/test_user_service.py:269
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/test_user_service.py:269: PytestUnknownMarkWarning: Unknown pytest.mark.users - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_live_system.py:26
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_live_system.py:26: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_live_system.py:27
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_live_system.py:27: PytestUnknownMarkWarning: Unknown pytest.mark.live - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_live_system.py:192
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_live_system.py:192: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_live_system.py:193
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_live_system.py:193: PytestUnknownMarkWarning: Unknown pytest.mark.live - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_live_system.py:194
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_live_system.py:194: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_live_system.py:259
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_live_system.py:259: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_live_system.py:260
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_live_system.py:260: PytestUnknownMarkWarning: Unknown pytest.mark.live - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_photo_pipeline.py:41
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:41: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_photo_pipeline.py:229
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:229: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/diagnostics/test_photo_pipeline.py:276
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/diagnostics/test_photo_pipeline.py:276: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_id_validation_integration.py:27
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_id_validation_integration.py:27: PytestUnknownMarkWarning: Unknown pytest.mark.id_validation - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_id_validation_integration.py:90
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_id_validation_integration.py:90: PytestUnknownMarkWarning: Unknown pytest.mark.photo_service - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_id_validation_integration.py:206
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_id_validation_integration.py:206: PytestUnknownMarkWarning: Unknown pytest.mark.id_management - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_id_validation_integration.py:296
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_id_validation_integration.py:296: PytestUnknownMarkWarning: Unknown pytest.mark.end_to_end - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_live_system.py:26
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_live_system.py:26: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_live_system.py:27
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_live_system.py:27: PytestUnknownMarkWarning: Unknown pytest.mark.live - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_live_system.py:192
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_live_system.py:192: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_live_system.py:193
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_live_system.py:193: PytestUnknownMarkWarning: Unknown pytest.mark.live - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_live_system.py:194
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_live_system.py:194: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_live_system.py:259
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_live_system.py:259: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_live_system.py:260
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_live_system.py:260: PytestUnknownMarkWarning: Unknown pytest.mark.live - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_photo_pipeline.py:41
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:41: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_photo_pipeline.py:229
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:229: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/test_photo_pipeline.py:276
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/test_photo_pipeline.py:276: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_live_system.py:26
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_live_system.py:26: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_live_system.py:27
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_live_system.py:27: PytestUnknownMarkWarning: Unknown pytest.mark.live - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_live_system.py:192
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_live_system.py:192: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_live_system.py:193
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_live_system.py:193: PytestUnknownMarkWarning: Unknown pytest.mark.live - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_live_system.py:194
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_live_system.py:194: PytestUnknownMarkWarning: Unknown pytest.mark.performance - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_live_system.py:259
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_live_system.py:259: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_live_system.py:260
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_live_system.py:260: PytestUnknownMarkWarning: Unknown pytest.mark.live - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_photo_pipeline.py:41
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:41: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_photo_pipeline.py:229
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:229: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/diagnostics/test_photo_pipeline.py:276
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/diagnostics/test_photo_pipeline.py:276: PytestUnknownMarkWarning: Unknown pytest.mark.diagnostics - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/integration/test_id_validation_integration.py:27
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_id_validation_integration.py:27: PytestUnknownMarkWarning: Unknown pytest.mark.id_validation - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/integration/test_id_validation_integration.py:90
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_id_validation_integration.py:90: PytestUnknownMarkWarning: Unknown pytest.mark.photo_service - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/integration/test_id_validation_integration.py:206
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_id_validation_integration.py:206: PytestUnknownMarkWarning: Unknown pytest.mark.id_management - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/edis-env/integration/test_id_validation_integration.py:296
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/edis-env/integration/test_id_validation_integration.py:296: PytestUnknownMarkWarning: Unknown pytest.mark.end_to_end - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/integration/test_id_validation_integration.py:27
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_id_validation_integration.py:27: PytestUnknownMarkWarning: Unknown pytest.mark.id_validation - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/integration/test_id_validation_integration.py:90
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_id_validation_integration.py:90: PytestUnknownMarkWarning: Unknown pytest.mark.photo_service - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/integration/test_id_validation_integration.py:206
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_id_validation_integration.py:206: PytestUnknownMarkWarning: Unknown pytest.mark.id_management - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

backend/tests/integration/test_id_validation_integration.py:296
  /home/cdc/Storage/NVMe/projects/lumen/backend/tests/integration/test_id_validation_integration.py:296: PytestUnknownMarkWarning: Unknown pytest.mark.end_to_end - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html

scripts/tests/test_photo_upload.py::test_photo_upload
  /home/cdc/Storage/NVMe/projects/lumen/backend/venv/lib/python3.11/site-packages/_pytest/python.py:198: PytestReturnNotNoneWarning: Expected None, but scripts/tests/test_photo_upload.py::test_photo_upload returned False, which will be an error in a future version of pytest.  Did you mean to use `assert` instead of `return`?
    warnings.warn(

scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_user_photo_relationship
  /home/cdc/Storage/NVMe/projects/lumen/backend/venv/lib/python3.11/site-packages/sqlalchemy/orm/context.py:2695: RuntimeWarning: coroutine 'PhotoService.get_recent_photos' was never awaited
    _instance = loading._instance_processor(
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_user_photo_relationship
  /home/cdc/Storage/NVMe/projects/lumen/backend/venv/lib/python3.11/site-packages/_pytest/fixtures.py:596: RuntimeWarning: coroutine 'PhotoService.get_recent_photos' was never awaited
    return self._fixture_defs[argname]
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_user_photo_relationship
  /home/cdc/Storage/NVMe/projects/lumen/backend/venv/lib/python3.11/site-packages/_pytest/fixtures.py:599: RuntimeWarning: coroutine 'PhotoService.get_recent_photos' was never awaited
    fixturedef = self._getnextfixturedef(argname)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_get_user_stats
scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_get_user_stats
  /home/cdc/Storage/NVMe/projects/lumen/backend/venv/lib/python3.11/site-packages/pytest_asyncio/plugin.py:451: DeprecationWarning: pytest-asyncio detected an unclosed event loop when tearing down the event_loop
  fixture: <_UnixSelectorEventLoop running=False closed=False debug=False>
  pytest-asyncio will close the event loop for you, but future versions of the
  library will no longer do so. In order to ensure compatibility with future
  versions, please make sure that:
      1. Any custom "event_loop" fixture properly closes the loop after yielding it
      2. The scopes of your custom "event_loop" fixtures do not overlap
      3. Your code does not modify the event loop in async fixtures or tests
  
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_unauthenticated
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_authenticated
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_unauthenticated
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_authenticated
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_logout_endpoint
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_test_endpoint
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint_unauthenticated
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_check_registration_existing_user
FAILED scripts/tests/test_auth_endpoints.py::TestAuthEndpoints::test_check_registration_new_user
FAILED scripts/tests/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_middleware_with_fastapi_dependency_injection
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_list_photos_with_pagination
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_authenticated
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_unauthenticated
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_photo_by_id
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_photo_not_found
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_owner
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_owner
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_not_owner
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_like_photo
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_search_photos
FAILED scripts/tests/test_photo_endpoints.py::TestPhotoEndpoints::test_get_user_photos_by_handle
FAILED scripts/tests/test_photo_model.py::TestPhotoModel::test_photo_model_creation
FAILED scripts/tests/test_photo_model.py::TestPhotoModel::test_photo_default_values
FAILED scripts/tests/test_photo_model.py::TestPhotoModel::test_photo_repr - s...
FAILED scripts/tests/test_photo_model.py::TestPhotoModel::test_like_count_property
FAILED scripts/tests/test_photo_model.py::TestPhotoModel::test_collaborator_names_property
FAILED scripts/tests/test_photo_model.py::TestPhotoModel::test_photographer_name_property_owner_is_photographer
FAILED scripts/tests/test_photo_model.py::TestPhotoModel::test_photographer_name_property_collaborator_is_photographer
FAILED scripts/tests/test_photo_model.py::TestPhotoModel::test_location_display_property
FAILED scripts/tests/test_photo_model.py::TestPhotoModel::test_is_liked_by_method
FAILED scripts/tests/test_user_model.py::TestUserModel::test_user_model_creation
FAILED scripts/tests/test_user_model.py::TestUserModel::test_user_default_values
FAILED scripts/tests/test_user_model.py::TestUserModel::test_user_type_properties
FAILED scripts/tests/test_user_model.py::TestUserModel::test_location_display_with_privacy
FAILED scripts/tests/test_user_model.py::TestUserModel::test_model_validation_requirements
FAILED scripts/tests/test_user_model.py::TestUserModel::test_photographer_validation_requirements
FAILED scripts/tests/test_user_model.py::TestUserPydanticModels::test_user_profile_models
FAILED scripts/tests/test_user_service.py::TestUserService::test_create_photographer_user
FAILED scripts/tests/test_user_service.py::TestUserService::test_create_model_user
FAILED scripts/tests/test_user_service.py::TestUserService::test_get_user_by_firebase_uid
FAILED scripts/tests/test_user_service.py::TestUserService::test_get_user_by_handle
FAILED scripts/tests/test_user_service.py::TestUserService::test_update_user_profile
FAILED scripts/tests/test_user_service.py::TestUserService::test_validate_unique_handle
FAILED scripts/tests/test_user_service.py::TestUserService::test_user_age_verification
FAILED scripts/tests/test_user_service.py::TestUserService::test_user_search_functionality
FAILED scripts/tests/test_user_service.py::TestUserService::test_user_profile_visibility
FAILED scripts/tests/test_user_service.py::TestUserService::test_user_content_permissions
FAILED scripts/tests/test_user_service.py::TestUserModelIntegration::test_user_model_creation_with_relationships
FAILED scripts/tests/test_user_service.py::TestUserModelIntegration::test_user_cascade_operations
FAILED scripts/tests/diagnostics/test_live_system.py::TestLiveSystemHealth::test_authenticated_endpoint_behavior
FAILED scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_initialization
FAILED scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_signed_url_generation
FAILED scripts/tests/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_recent_photos
FAILED scripts/tests/diagnostics/test_photo_pipeline.py::TestAuthenticationFlow::test_firebase_token_validation
FAILED scripts/tests/diagnostics/test_photo_pipeline.py::TestAuthenticationFlow::test_auth_middleware_error_handling
FAILED scripts/tests/diagnostics/test_photo_pipeline.py::TestExternalServiceIntegration::test_gcs_bucket_accessibility
FAILED scripts/tests/edis-env/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_middleware_with_fastapi_dependency_injection
FAILED scripts/tests/edis-env/test_id_validation_integration.py::TestIDValidationIntegration::test_valid_firebase_uid_formats
FAILED scripts/tests/edis-env/test_live_system.py::TestLiveSystemHealth::test_authenticated_endpoint_behavior
FAILED scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_like_count_property
FAILED scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_collaborator_names_property
FAILED scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photographer_name_property_owner_is_photographer
FAILED scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photographer_name_property_collaborator_is_photographer
FAILED scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_location_display_property
FAILED scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_is_liked_by_method
FAILED scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_initialization
FAILED scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_signed_url_generation
FAILED scripts/tests/edis-env/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_recent_photos
FAILED scripts/tests/edis-env/test_photo_pipeline.py::TestAuthenticationFlow::test_firebase_token_validation
FAILED scripts/tests/edis-env/test_photo_pipeline.py::TestAuthenticationFlow::test_auth_middleware_error_handling
FAILED scripts/tests/edis-env/test_photo_pipeline.py::TestExternalServiceIntegration::test_gcs_bucket_accessibility
FAILED scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_delete_nonexistent_user
FAILED scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_gmail_profile_image_not_deleted
FAILED scripts/tests/edis-env/test_user_model.py::TestUserModel::test_user_type_properties
FAILED scripts/tests/edis-env/test_user_model.py::TestUserModel::test_location_display_with_privacy
FAILED scripts/tests/edis-env/test_user_model.py::TestUserModel::test_model_validation_requirements
FAILED scripts/tests/edis-env/test_user_model.py::TestUserModel::test_photographer_validation_requirements
FAILED scripts/tests/edis-env/test_user_model.py::TestUserPydanticModels::test_user_profile_models
FAILED scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_with_artistic_statement
FAILED scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_photographer_specific_fields
FAILED scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_model_specific_fields
FAILED scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_availability_data
FAILED scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_success
FAILED scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_failure
FAILED scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_update_profile_image_url
FAILED scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_remove_profile_image
FAILED scripts/tests/edis-env/test_user_service_enhanced.py::TestEnhancedUserService::test_get_user_stats
FAILED scripts/tests/edis-env/diagnostics/test_live_system.py::TestLiveSystemHealth::test_authenticated_endpoint_behavior
FAILED scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_initialization
FAILED scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_signed_url_generation
FAILED scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestPhotoDisplayPipeline::test_photo_service_recent_photos
FAILED scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestAuthenticationFlow::test_firebase_token_validation
FAILED scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestAuthenticationFlow::test_auth_middleware_error_handling
FAILED scripts/tests/edis-env/diagnostics/test_photo_pipeline.py::TestExternalServiceIntegration::test_gcs_bucket_accessibility
FAILED scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_valid_firebase_uid_formats
FAILED scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_delete_nonexistent_user
FAILED scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_gmail_profile_image_not_deleted
FAILED scripts/tests/edis-env/unit/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_middleware_with_fastapi_dependency_injection
FAILED scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_like_count_property
FAILED scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_collaborator_names_property
FAILED scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photographer_name_property_owner_is_photographer
FAILED scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photographer_name_property_collaborator_is_photographer
FAILED scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_location_display_property
FAILED scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_is_liked_by_method
FAILED scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_user_type_properties
FAILED scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_location_display_with_privacy
FAILED scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_model_validation_requirements
FAILED scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_photographer_validation_requirements
FAILED scripts/tests/edis-env/unit/test_user_model.py::TestUserPydanticModels::test_user_profile_models
FAILED scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_with_artistic_statement
FAILED scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_photographer_specific_fields
FAILED scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_model_specific_fields
FAILED scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_availability_data
FAILED scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_success
FAILED scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_failure
FAILED scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_profile_image_url
FAILED scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_remove_profile_image
FAILED scripts/tests/edis-env/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_get_user_stats
FAILED scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_unauthenticated
FAILED scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_authenticated
FAILED scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_unauthenticated
FAILED scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_authenticated
FAILED scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint
FAILED scripts/tests/integration/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint_unauthenticated
FAILED scripts/tests/integration/test_database_integration.py::TestDatabaseConnection::test_database_session_creation
FAILED scripts/tests/integration/test_database_integration.py::TestDatabaseConnection::test_database_transaction_rollback
FAILED scripts/tests/integration/test_database_integration.py::TestUserDatabaseOperations::test_create_user_with_relationships
FAILED scripts/tests/integration/test_database_integration.py::TestUserDatabaseOperations::test_user_unique_constraints
FAILED scripts/tests/integration/test_database_integration.py::TestUserDatabaseOperations::test_user_cascade_delete
FAILED scripts/tests/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_create_photo_with_metadata
FAILED scripts/tests/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_collaborator_relationships
FAILED scripts/tests/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_interaction_tracking
FAILED scripts/tests/integration/test_database_integration.py::TestDatabasePerformance::test_user_photo_query_efficiency
FAILED scripts/tests/integration/test_database_integration.py::TestDatabasePerformance::test_photo_search_with_indexes
FAILED scripts/tests/integration/test_id_validation_integration.py::TestIDValidationIntegration::test_valid_firebase_uid_formats
FAILED scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_photo_id
FAILED scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_valid_uid
FAILED scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_invalid_uid
FAILED scripts/tests/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_complete_photo_upload_flow
FAILED scripts/tests/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_photo_retrieval_with_id_validation
FAILED scripts/tests/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_invalid_id_formats_rejected_in_flow
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_empty
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_with_pagination
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_list_photos_public_endpoint
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_nonexistent_photo
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_authenticated
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_unauthenticated
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_user_photos_endpoint
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_specific_user_photos
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_success
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_unauthenticated
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_invalid_file_type
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_authenticated
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_unauthenticated
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_authenticated
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_unauthenticated
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_like_photo_not_implemented
FAILED scripts/tests/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_search_photos_not_implemented
FAILED scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_delete_nonexistent_user
FAILED scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_gmail_profile_image_not_deleted
FAILED scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_orphaned_photos_check
FAILED scripts/tests/integration/test_user_deletion.py::test_delete_user_endpoint_requires_confirmation
FAILED scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_success
FAILED scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_invalid_token
FAILED scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_current_user_firebase_exception
FAILED scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_success
FAILED scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_no_credentials
FAILED scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_invalid_token
FAILED scripts/tests/unit/test_auth_middleware.py::TestAuthMiddleware::test_get_optional_user_firebase_returns_none
FAILED scripts/tests/unit/test_auth_middleware.py::TestAuthMiddlewareIntegration::test_middleware_with_fastapi_dependency_injection
FAILED scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photo_model_creation
FAILED scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photo_default_values
FAILED scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photo_repr
FAILED scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_like_count_property
FAILED scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_collaborator_names_property
FAILED scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photographer_name_property_owner_is_photographer
FAILED scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_photographer_name_property_collaborator_is_photographer
FAILED scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_location_display_property
FAILED scripts/tests/unit/test_photo_model.py::TestPhotoModel::test_is_liked_by_method
FAILED scripts/tests/unit/test_user_model.py::TestUserModel::test_user_model_creation
FAILED scripts/tests/unit/test_user_model.py::TestUserModel::test_user_default_values
FAILED scripts/tests/unit/test_user_model.py::TestUserModel::test_user_type_properties
FAILED scripts/tests/unit/test_user_model.py::TestUserModel::test_location_display_with_privacy
FAILED scripts/tests/unit/test_user_model.py::TestUserModel::test_model_validation_requirements
FAILED scripts/tests/unit/test_user_model.py::TestUserModel::test_photographer_validation_requirements
FAILED scripts/tests/unit/test_user_model.py::TestUserPydanticModels::test_user_profile_models
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_with_artistic_statement
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_photographer_specific_fields
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_model_specific_fields
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_user_profile_availability_data
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_success
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_upload_profile_image_failure
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_update_profile_image_url
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_remove_profile_image
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_user_exists
FAILED scripts/tests/unit/test_user_service_enhanced.py::TestEnhancedUserService::test_get_user_stats
ERROR scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_unauthenticated
ERROR scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_authenticated
ERROR scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_unauthenticated
ERROR scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_authenticated
ERROR scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_logout_endpoint
ERROR scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_test_endpoint
ERROR scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint
ERROR scripts/tests/edis-env/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint_unauthenticated
ERROR scripts/tests/edis-env/test_database_integration.py::TestDatabaseConnection::test_database_session_creation
ERROR scripts/tests/edis-env/test_database_integration.py::TestDatabaseConnection::test_database_transaction_rollback
ERROR scripts/tests/edis-env/test_database_integration.py::TestUserDatabaseOperations::test_create_user_with_relationships
ERROR scripts/tests/edis-env/test_database_integration.py::TestUserDatabaseOperations::test_user_unique_constraints
ERROR scripts/tests/edis-env/test_database_integration.py::TestUserDatabaseOperations::test_user_cascade_delete
ERROR scripts/tests/edis-env/test_database_integration.py::TestPhotoDatabaseOperations::test_create_photo_with_metadata
ERROR scripts/tests/edis-env/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_collaborator_relationships
ERROR scripts/tests/edis-env/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_interaction_tracking
ERROR scripts/tests/edis-env/test_database_integration.py::TestDatabasePerformance::test_user_photo_query_efficiency
ERROR scripts/tests/edis-env/test_database_integration.py::TestDatabasePerformance::test_photo_search_with_indexes
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_valid_ids
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_firebase_uid
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_photo_id
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_valid_uid
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_invalid_uid
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_user_id_integration
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_photo_id_integration
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_generate_storage_paths_integration
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_parse_storage_path_integration
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_prepare_ids_for_operation_integration
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_complete_photo_upload_flow
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_photo_retrieval_with_id_validation
ERROR scripts/tests/edis-env/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_invalid_id_formats_rejected_in_flow
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_empty
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_with_pagination
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_invalid_pagination
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_list_photos_public_endpoint
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_nonexistent_photo
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_authenticated
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_unauthenticated
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_user_photos_endpoint
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_get_specific_user_photos
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_success
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_unauthenticated
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_invalid_file_type
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_authenticated
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_unauthenticated
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_authenticated
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_unauthenticated
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_like_photo_not_implemented
ERROR scripts/tests/edis-env/test_photo_endpoints.py::TestPhotoEndpoints::test_search_photos_not_implemented
ERROR scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photo_model_creation
ERROR scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photo_default_values
ERROR scripts/tests/edis-env/test_photo_model.py::TestPhotoModel::test_photo_repr
ERROR scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_get_deletion_summary
ERROR scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_delete_user_account_success
ERROR scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_deletion_with_storage_errors
ERROR scripts/tests/edis-env/test_user_deletion.py::TestUserDeletion::test_deletion_rollback_on_db_error
ERROR scripts/tests/edis-env/test_user_deletion.py::test_delete_user_endpoint_requires_confirmation
ERROR scripts/tests/edis-env/test_user_model.py::TestUserModel::test_user_model_creation
ERROR scripts/tests/edis-env/test_user_model.py::TestUserModel::test_user_default_values
ERROR scripts/tests/edis-env/test_user_model.py::TestUserModel::test_user_repr
ERROR scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_unauthenticated
ERROR scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_auth_status_authenticated
ERROR scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_unauthenticated
ERROR scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_get_profile_authenticated
ERROR scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_logout_endpoint
ERROR scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_test_endpoint
ERROR scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint
ERROR scripts/tests/edis-env/integration/test_auth_endpoints.py::TestAuthEndpoints::test_demo_protected_endpoint_unauthenticated
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestDatabaseConnection::test_database_session_creation
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestDatabaseConnection::test_database_transaction_rollback
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestUserDatabaseOperations::test_create_user_with_relationships
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestUserDatabaseOperations::test_user_unique_constraints
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestUserDatabaseOperations::test_user_cascade_delete
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_create_photo_with_metadata
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_collaborator_relationships
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestPhotoDatabaseOperations::test_photo_interaction_tracking
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestDatabasePerformance::test_user_photo_query_efficiency
ERROR scripts/tests/edis-env/integration/test_database_integration.py::TestDatabasePerformance::test_photo_search_with_indexes
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_valid_ids
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_firebase_uid
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_photo_id
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_valid_uid
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_ensure_user_exists_with_invalid_uid
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_user_id_integration
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_normalize_photo_id_integration
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_generate_storage_paths_integration
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_parse_storage_path_integration
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestIDManagementServiceIntegration::test_prepare_ids_for_operation_integration
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_complete_photo_upload_flow
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_photo_retrieval_with_id_validation
ERROR scripts/tests/edis-env/integration/test_id_validation_integration.py::TestEndToEndPhotoFlow::test_invalid_id_formats_rejected_in_flow
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_empty
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_with_pagination
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_recent_photos_invalid_pagination
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_list_photos_public_endpoint
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_nonexistent_photo
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_authenticated
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_my_photos_unauthenticated
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_user_photos_endpoint
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_get_specific_user_photos
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_success
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_photo_unauthenticated
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_upload_invalid_file_type
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_authenticated
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_update_photo_unauthenticated
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_authenticated
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_delete_photo_unauthenticated
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_like_photo_not_implemented
ERROR scripts/tests/edis-env/integration/test_photo_endpoints.py::TestPhotoEndpoints::test_search_photos_not_implemented
ERROR scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_get_deletion_summary
ERROR scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_delete_user_account_success
ERROR scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_deletion_with_storage_errors
ERROR scripts/tests/edis-env/integration/test_user_deletion.py::TestUserDeletion::test_deletion_rollback_on_db_error
ERROR scripts/tests/edis-env/integration/test_user_deletion.py::test_delete_user_endpoint_requires_confirmation
ERROR scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photo_model_creation
ERROR scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photo_default_values
ERROR scripts/tests/edis-env/unit/test_photo_model.py::TestPhotoModel::test_photo_repr
ERROR scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_user_model_creation
ERROR scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_user_default_values
ERROR scripts/tests/edis-env/unit/test_user_model.py::TestUserModel::test_user_repr
ERROR scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_valid_ids
ERROR scripts/tests/integration/test_id_validation_integration.py::TestPhotoServiceIDValidation::test_photo_service_with_invalid_firebase_uid
ERROR scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_get_deletion_summary
ERROR scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_delete_user_account_success
ERROR scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_deletion_with_storage_errors
ERROR scripts/tests/integration/test_user_deletion.py::TestUserDeletion::test_deletion_rollback_on_db_error
========== 199 failed, 274 passed, 64 warnings, 126 errors in 45.51s ===========
Running tests with PYTHONPATH= /home/cdc/Storage/NVMe/projects/lumen/backend:
